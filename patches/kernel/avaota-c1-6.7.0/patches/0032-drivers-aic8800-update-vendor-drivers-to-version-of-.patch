From b7425c8231aee4be3b780eaf43d6679edcddf9e1 Mon Sep 17 00:00:00 2001
From: Tiandi Zhou <zhoutiandi@sipeed.com>
Date: Mon, 26 Feb 2024 10:54:27 +0800
Subject: [PATCH 32/36] drivers: aic8800: update vendor drivers to version of
 20231212

---
 drivers/bluetooth/aic_btusb.c                 |  65 +-
 drivers/bluetooth/aic_btusb.h                 |   2 +
 .../wireless/aic8800/aic8800_fdrv/.gitignore  |  10 +
 .../wireless/aic8800/aic8800_fdrv/Makefile    |  23 +-
 .../aic8800/aic8800_fdrv/aic_vendor.c         |  36 +-
 .../aic8800_fdrv/aicwf_compat_8800dc.c        | 359 +++++++++-
 .../aic8800_fdrv/aicwf_compat_8800dc.h        |  35 +-
 .../aic8800/aic8800_fdrv/aicwf_rx_prealloc.h  |   2 +-
 .../aic8800/aic8800_fdrv/aicwf_tcp_ack.c      | 633 ++++++++++++++++++
 .../aic8800/aic8800_fdrv/aicwf_tcp_ack.h      | 111 +++
 .../aic8800/aic8800_fdrv/aicwf_txrxif.c       |   2 +-
 .../wireless/aic8800/aic8800_fdrv/aicwf_usb.c | 101 ++-
 .../wireless/aic8800/aic8800_fdrv/aicwf_usb.h |  12 +-
 .../aic8800/aic8800_fdrv/aicwf_wext_linux.c   |  31 +-
 .../wireless/aic8800/aic8800_fdrv/lmac_msg.h  |  89 +++
 .../wireless/aic8800/aic8800_fdrv/rwnx_cmds.c |  14 +-
 .../aic8800/aic8800_fdrv/rwnx_debugfs.c       | 117 +++-
 .../wireless/aic8800/aic8800_fdrv/rwnx_defs.h |  38 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_main.c | 230 +++++--
 .../aic8800/aic8800_fdrv/rwnx_mod_params.c    |  19 +-
 .../aic8800/aic8800_fdrv/rwnx_msg_rx.c        | 154 ++++-
 .../aic8800/aic8800_fdrv/rwnx_msg_tx.c        | 224 ++++---
 .../aic8800/aic8800_fdrv/rwnx_msg_tx.h        |   4 +-
 .../aic8800/aic8800_fdrv/rwnx_platform.c      |  53 +-
 .../aic8800/aic8800_fdrv/rwnx_platform.h      |   4 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_rx.c   |  32 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_tx.c   | 187 +++++-
 .../wireless/aic8800/aic8800_fdrv/rwnx_txq.c  |   4 +-
 .../aic8800/aic8800_fdrv/rwnx_utils.h         |   6 -
 .../aic8800/aic8800_fdrv/rwnx_version_gen.h   |   2 +-
 .../wireless/aic8800/aic_load_fw/.gitignore   |  11 +
 .../net/wireless/aic8800/aic_load_fw/Makefile |   7 +-
 .../aic8800/aic_load_fw/aic_bluetooth_main.c  |   8 +
 .../aic8800/aic_load_fw/aic_compat_8800d80.c  | 111 ++-
 .../aic8800/aic_load_fw/aic_compat_8800d80.h  |   5 +
 .../aic8800/aic_load_fw/aicbluetooth.c        | 164 ++++-
 .../aic8800/aic_load_fw/aicbluetooth.h        |   1 +
 .../aic8800/aic_load_fw/aicbluetooth_cmds.c   |   1 -
 .../aic8800/aic_load_fw/aicwf_rx_prealloc.c   |   7 +-
 .../aic8800/aic_load_fw/aicwf_txq_prealloc.c  |   2 +-
 .../wireless/aic8800/aic_load_fw/aicwf_usb.c  |  96 ++-
 .../wireless/aic8800/aic_load_fw/aicwf_usb.h  |  36 +-
 .../aic8800/aic_load_fw/rwnx_version_gen.h    |   2 +-
 43 files changed, 2625 insertions(+), 425 deletions(-)
 mode change 100755 => 100644 drivers/bluetooth/aic_btusb.c
 mode change 100755 => 100644 drivers/bluetooth/aic_btusb.h
 create mode 100644 drivers/net/wireless/aic8800/aic8800_fdrv/.gitignore
 create mode 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c
 create mode 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h
 create mode 100644 drivers/net/wireless/aic8800/aic_load_fw/.gitignore

diff --git a/drivers/bluetooth/aic_btusb.c b/drivers/bluetooth/aic_btusb.c
old mode 100755
new mode 100644
index 754c2aef8adc..334e68c46150
--- a/drivers/bluetooth/aic_btusb.c
+++ b/drivers/bluetooth/aic_btusb.c
@@ -72,6 +72,12 @@ u16 g_chipid = PRODUCT_ID_AIC8801;
 u8 chip_id = 0;
 u8 sub_chip_id = 0;
 
+int btdual = 0;
+int bt_support = 0;
+
+module_param(btdual, int, 0660);
+module_param(bt_support, int, 0660);
+
 struct btusb_data {
     struct hci_dev       *hdev;
     struct usb_device    *udev;
@@ -149,8 +155,6 @@ static struct snd_sco_cap_timer snd_cap_timer;
 #endif
 
 
-int bt_support = 0;
-module_param(bt_support, int, 0660);
 
 #ifdef CONFIG_SUPPORT_VENDOR_APCF
 int vendor_apcf_sent_done = 0;
@@ -586,7 +590,9 @@ static int aic_skb_queue_rear = 0;
 
 static void aic_enqueue(struct sk_buff *skb)
 {
-    spin_lock(&queue_lock);
+	unsigned long flags = 0;
+	
+	spin_lock_irqsave(&queue_lock, flags);
     if (aic_skb_queue_front == (aic_skb_queue_rear + 1) % QUEUE_SIZE) {
         /*
          * If queue is full, current solution is to drop
@@ -600,16 +606,19 @@ static void aic_enqueue(struct sk_buff *skb)
         aic_skb_queue_rear %= QUEUE_SIZE;
 
     }
-    spin_unlock(&queue_lock);
+	spin_unlock_irqrestore(&queue_lock, flags);
 }
 
 static struct sk_buff *aic_dequeue_try(unsigned int deq_len)
 {
     struct sk_buff *skb;
     struct sk_buff *skb_copy;
-
+	unsigned long flags = 0;
+	
+	spin_lock_irqsave(&queue_lock, flags);
     if (aic_skb_queue_front == aic_skb_queue_rear) {
         AICBT_WARN("%s: Queue is empty", __func__);
+		spin_unlock_irqrestore(&queue_lock, flags);
         return NULL;
     }
 
@@ -623,11 +632,13 @@ static struct sk_buff *aic_dequeue_try(unsigned int deq_len)
          * Return skb addr to be dequeued, and the caller
          * should free the skb eventually.
          */
+		spin_unlock_irqrestore(&queue_lock, flags);
         return skb;
     } else {
         skb_copy = pskb_copy(skb, GFP_ATOMIC);
         skb_pull(skb, deq_len);
         /* Return its copy to be freed */
+		spin_unlock_irqrestore(&queue_lock, flags);
         return skb_copy;
     }
 }
@@ -640,7 +651,9 @@ static inline int is_queue_empty(void)
 static void aic_clear_queue(void)
 {
     struct sk_buff *skb;
-    spin_lock(&queue_lock);
+	unsigned long flags = 0;
+	
+	spin_lock_irqsave(&queue_lock, flags);
     while(!is_queue_empty()) {
         skb = aic_skb_queue[aic_skb_queue_front];
         aic_skb_queue[aic_skb_queue_front] = NULL;
@@ -650,7 +663,7 @@ static void aic_clear_queue(void)
             kfree_skb(skb);
         }
     }
-    spin_unlock(&queue_lock);
+	spin_unlock_irqrestore(&queue_lock, flags);
 }
 
 /*
@@ -1747,6 +1760,8 @@ int system_config(firmware_info *fw_info)
         uint32_t rd_data = (evt_para->data[0] | (evt_para->data[1] << 8) | (evt_para->data[2] << 16) | (evt_para->data[3] << 24));
         //printk("%s 0x40500000 rd_data is %x\n", __func__, rd_data);
         chip_id = (u8) (rd_data >> 16);
+		//btenable = (u8) ((rd_data >> 26) && 0x01);
+		btdual = (u8) ((rd_data >> 27) && 0x01);
     }
 
     rd_cmd->start_addr = 0x20;
@@ -2501,10 +2516,32 @@ int download_patch(firmware_info *fw_info, int cached)
                 printk("aic load patch ftable ail %d\n", ret_val);
                 goto free;
             }
-        } else {
+        } else if (sub_chip_id == 2) {
+            uint32_t fw_ram_patch_base_addr = FW_RAM_PATCH_BASE_ADDR;
+
+            ret_val = get_patch_addr_from_patch_table(fw_info, FW_PATCH_TABLE_NAME_U02H, &fw_ram_patch_base_addr);
+            if (ret_val)
+            {
+                printk("aic get patch addr fail %d\n", ret_val);
+                goto free;
+            }
+            printk("U02H %s %x\n", __func__, fw_ram_patch_base_addr);
+            ret_val = download_data(fw_info, fw_ram_patch_base_addr, FW_PATCH_BASE_NAME_U02H);
+            if (ret_val)
+            {
+                printk("aic load patch fail %d\n", ret_val);
+                goto free;
+            }
+
+            ret_val = patch_table_download(fw_info, FW_PATCH_TABLE_NAME_U02H);
+            if (ret_val)
+            {
+                printk("aic load patch ftable ail %d\n", ret_val);
+                goto free;
+            }
+	} else {
             printk("%s unsupported sub_chip_id %x\n", __func__, sub_chip_id);
         }
-
     }
 
 free:
@@ -3740,8 +3777,10 @@ int btusb_send_frame(struct hci_dev *hdev, struct sk_buff *skb)
         }
         kfree(urb->setup_packet);
         usb_unanchor_urb(urb);
-    } else
+    } else{
+    	
         usb_mark_last_busy(data->udev);
+    }
     usb_free_urb(urb);
 
 done:
@@ -4522,8 +4561,8 @@ static int btusb_probe(struct usb_interface *intf, const struct usb_device_id *i
     firmware_info *fw_info;
     int i, err=0;
 
-    bt_support = 1;
-    
+	bt_support = 1;
+	
     AICBT_INFO("%s: usb_interface %p, bInterfaceNumber %d, idVendor 0x%04x, "
             "idProduct 0x%04x", __func__, intf,
             intf->cur_altsetting->desc.bInterfaceNumber,
@@ -4966,7 +5005,7 @@ static int __init btusb_init(void)
 
     AICBT_INFO("AICBT_RELEASE_NAME: %s",AICBT_RELEASE_NAME);
     AICBT_INFO("AicSemi Bluetooth USB driver module init, version %s", VERSION);
-	AICBT_INFO("RELEASE DATE: 2023_0506_1635 \r\n");
+	AICBT_INFO("RELEASE DATE: 2023_1211_1958 \r\n");
 #if CONFIG_BLUEDROID
     err = btchr_init();
     if (err < 0) {
diff --git a/drivers/bluetooth/aic_btusb.h b/drivers/bluetooth/aic_btusb.h
old mode 100755
new mode 100644
index 4c212acd5003..badbd636856a
--- a/drivers/bluetooth/aic_btusb.h
+++ b/drivers/bluetooth/aic_btusb.h
@@ -663,6 +663,8 @@ typedef struct {
 #define FW_PATCH_BASE_NAME              "fw_patch_8800dc.bin"
 #define FW_PATCH_TABLE_NAME_U02         "fw_patch_table_8800dc_u02.bin"
 #define FW_PATCH_BASE_NAME_U02          "fw_patch_8800dc_u02.bin"
+#define FW_PATCH_TABLE_NAME_U02H        "fw_patch_table_8800dc_u02h.bin"
+#define FW_PATCH_BASE_NAME_U02H         "fw_patch_8800dc_u02h.bin"
 #define AICBT_PT_TAG                    "AICBT_PT_TAG"
 
 enum aicbt_patch_table_type {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/.gitignore b/drivers/net/wireless/aic8800/aic8800_fdrv/.gitignore
new file mode 100644
index 000000000000..c3c2d151e157
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/.gitignore
@@ -0,0 +1,10 @@
+*.o
+*.ko
+*.order
+*.symvers
+*.o.d
+*.o.cmd
+*.ko.cmd
+*.mod
+*.mod.c
+*.mod.cmd
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile b/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
index 1ae275d8928d..17b64f397be7 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
@@ -1,5 +1,6 @@
-#EXTRA_CFLAGS += $(USER_EXTRA_CFLAGS)
-#EXTRA_CFLAGS += -Wno-implicit-fallthrough
+EXTRA_CFLAGS += $(USER_EXTRA_CFLAGS)
+EXTRA_CFLAGS += -Wno-implicit-fallthrough
+#EXTRA_CFLAGS += -Wno-unused-variable
 
 RWNX_VERS_NUM := 6.4.3.0
 
@@ -71,9 +72,9 @@ CONFIG_HE_FOR_OLD_KERNEL ?= n
 CONFIG_VHT_FOR_OLD_KERNEL ?= n
 # CONFIG_COEX = n for BT_ONLY, CONFIG_COEX =y for combo and sw
 CONFIG_COEX = y
-CONFIG_ALIGN_8BYTES = n
-CONFIG_TXRX_THREAD_PRIO = n
-CONFIG_USB_ALIGN_DATA = n
+CONFIG_ALIGN_8BYTES = y
+CONFIG_TXRX_THREAD_PRIO = y
+CONFIG_USB_ALIGN_DATA = y
 CONFIG_RX_TASKLET = n
 CONFIG_TX_TASKLET = n
 CONFIG_RX_NETIF_RECV_SKB = y
@@ -105,10 +106,11 @@ CONFIG_PER_STA_FC = n
 CONFIG_PREALLOC_RX_SKB = n
 CONFIG_PREALLOC_TXQ = y
 CONFIG_USE_WIRELESS_EXT = n
-CONFIG_DPD = n
-CONFIG_FORCE_DPD_CALIB = n
+CONFIG_DPD = y
+CONFIG_FORCE_DPD_CALIB = y
 CONFIG_GKI = n
 CONFIG_SCHED_SCAN = n
+CONFIG_TEMP_COMP = n
 
 # Support of MU-MIMO transmission (need FW support)
 ifeq ($(CONFIG_RWNX_BFMER), y)
@@ -128,6 +130,8 @@ CONFIG_RWNX_MON_DATA =n
 CONFIG_RWNX_MON_XMIT ?= n
 CONFIG_RWNX_MON_RXFILTER ?= n
 
+CONFIG_FILTER_TCP_ACK =n
+
 # extra DEBUG config
 CONFIG_RWNX_SW_PROFILING ?= n
 CONFIG_RWNX_DBG ?= n
@@ -158,7 +162,7 @@ $(MODULE_NAME)-y := \
 	md5.o                  \
 	aic_vendor.o           \
 	aicwf_compat_8800dc.o  \
-	aicwf_compat_8800d80.o  \
+	aicwf_compat_8800d80.o
 
 $(MODULE_NAME)-$(CONFIG_BR_SUPPORT)       += aic_br_ext.o
 $(MODULE_NAME)-$(CONFIG_RWNX_RADAR)       += rwnx_radar.o
@@ -170,6 +174,7 @@ $(MODULE_NAME)-$(CONFIG_RWNX_MUMIMO_TX)   += rwnx_mu_group.o
 $(MODULE_NAME)-$(CONFIG_SDIO_SUPPORT)     += sdio_host.o
 $(MODULE_NAME)-$(CONFIG_SDIO_SUPPORT)     += aicwf_txrxif.o
 $(MODULE_NAME)-$(CONFIG_SDIO_SUPPORT)     += aicwf_sdio.o
+$(MODULE_NAME)-$(CONFIG_FILTER_TCP_ACK)   += aicwf_tcp_ack.o
 
 $(MODULE_NAME)-$(CONFIG_USB_SUPPORT)     += usb_host.o
 $(MODULE_NAME)-$(CONFIG_USB_SUPPORT)     += aicwf_txrxif.o
@@ -295,6 +300,8 @@ ccflags-$(CONFIG_DPD) += -DCONFIG_DPD
 ccflags-$(CONFIG_FORCE_DPD_CALIB) += -DCONFIG_FORCE_DPD_CALIB -DCONFIG_DPD
 ccflags-$(CONFIG_GKI) += -DCONFIG_GKI
 ccflags-$(CONFIG_SCHED_SCAN) += -DCONFIG_SCHED_SCAN
+ccflags-$(CONFIG_FILTER_TCP_ACK) += -DCONFIG_FILTER_TCP_ACK
+ccflags-$(CONFIG_TEMP_COMP) += -DCONFIG_TEMP_COMP
 
 # Platform support list
 CONFIG_PLATFORM_ROCKCHIP ?= n
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
index 4e70583bd770..5ef5995fa4ba 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
@@ -660,7 +660,8 @@ aicwf_cfg80211_subcmd_set_mac_policy[WIFI_VENDOR_ATTR_DRIVER_MAX + 1] = {
 	[0] = {.type = NLA_UNSPEC },
 	[WIFI_VENDOR_ATTR_DRIVER_MAC_ADDR] = { .type = NLA_MSECS, .len  = ETH_ALEN },
 };
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 static int aicwf_dump_interface(struct wiphy *wiphy,
 				struct wireless_dev *wdev, struct sk_buff *skb,
 				const void *data, int data_len,
@@ -668,6 +669,9 @@ static int aicwf_dump_interface(struct wiphy *wiphy,
 {
 	return 0;
 }
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 
 const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 	{
@@ -677,7 +681,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_start_mkeep_alive,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_mkeep_alive_policy,
 		.maxattr = MKEEP_ALIVE_ATTRIBUTE_MAX
@@ -690,7 +696,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_stop_mkeep_alive,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_mkeep_alive_policy,
 		.maxattr = MKEEP_ALIVE_ATTRIBUTE_MAX
@@ -703,7 +711,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_get_ver,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_logger_policy,
 		.maxattr = LOGGER_ATTRIBUTE_MAX
@@ -716,7 +726,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_subcmd_get_channel_list,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_subcmd_policy,
 		.maxattr = GSCAN_ATTRIBUTE_MAX
@@ -729,7 +741,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_subcmd_set_country_code,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_andr_wifi_policy,
 		.maxattr = ANDR_WIFI_ATTRIBUTE_MAX
@@ -742,7 +756,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_trigger_memory_dump,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -754,7 +770,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_subcmd_get_feature_set,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -766,7 +784,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_get_feature,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -778,7 +798,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_get_ring_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -790,7 +812,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_start_logging,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_logger_policy,
 		.maxattr = LOGGER_ATTRIBUTE_MAX
@@ -803,7 +827,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_get_ring_data,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_logger_policy,
 		.maxattr = LOGGER_ATTRIBUTE_MAX
@@ -816,7 +842,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_get_wake_reason_stats,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -828,7 +856,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_apf_subcmd_get_capabilities,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -840,7 +870,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_RUNNING,
 		.doit = aicwf_vendor_sub_cmd_set_mac,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_subcmd_set_mac_policy,
 		.maxattr = WIFI_VENDOR_ATTR_DRIVER_MAX,
@@ -853,7 +885,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
         },
         .flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_RUNNING,
         .doit = aicwf_vendor_sub_cmd_set_mac,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
         .dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
         .policy = aicwf_cfg80211_subcmd_set_mac_policy,
         .maxattr = WIFI_VENDOR_ATTR_DRIVER_MAX,
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
index d8c11aa07f2c..a1e542368d19 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
@@ -13,9 +13,11 @@
 #endif
 #define RWNX_MAC_PATCH_NAME2_8800DC RWNX_MAC_PATCH_BASE_NAME_8800DC".bin"
 #define RWNX_MAC_PATCH_NAME2_8800DC_U02 RWNX_MAC_PATCH_BASE_NAME_8800DC"_u02.bin"
+#define RWNX_MAC_PATCH_NAME2_8800DC_H_U02 RWNX_MAC_PATCH_BASE_NAME_8800DC"_h_u02.bin"
 
 #define RWNX_MAC_CALIB_BASE_NAME_8800DC        "fmacfw_calib_8800dc"
 #define RWNX_MAC_CALIB_NAME_8800DC_U02          RWNX_MAC_CALIB_BASE_NAME_8800DC"_u02.bin"
+#define RWNX_MAC_CALIB_NAME_8800DC_H_U02        RWNX_MAC_CALIB_BASE_NAME_8800DC"_h_u02.bin"
 
 #ifdef CONFIG_FOR_IPCAM
 #define RWNX_MAC_PATCH_TABLE_NAME_8800DC "fmacfw_patch_tbl_8800dc_ipc"
@@ -24,6 +26,7 @@
 #endif
 #define RWNX_MAC_PATCH_TABLE_8800DC RWNX_MAC_PATCH_TABLE_NAME_8800DC ".bin"
 #define RWNX_MAC_PATCH_TABLE_8800DC_U02 RWNX_MAC_PATCH_TABLE_NAME_8800DC "_u02.bin"
+#define RWNX_MAC_PATCH_TABLE_8800DC_H_U02 RWNX_MAC_PATCH_TABLE_NAME_8800DC "_h_u02.bin"
 
 
 #define RWNX_MAC_RF_PATCH_BASE_NAME_8800DC     "fmacfw_rf_patch_8800dc"
@@ -1520,7 +1523,7 @@ uint32_t txgain_map[96] =  {
     0x00ffcc85,
     0x00ffcd70,
     0x00ffcd80,
-    0x00ffce70,
+    0x00ffcd90,
     0x00ffce80,
     0x00ffce93,
     0x00ffcf90,
@@ -1543,6 +1546,109 @@ uint32_t txgain_map[96] =  {
 #endif
 };
 
+const uint32_t txgain_map_h[96] =
+{
+    //11b
+    0xffd888, //11
+    0xffd979, //12
+    0xffd988, //13
+    0xffda79, //14
+    0xffda88, //15
+    0xffdb79, //16
+    0xffdb88, //17
+    0xffdc72, //18
+    0xffdc80, //19
+    0xffdd80, //20
+    0xffde66, //21
+    0xffde72, //22
+    0xffde80, //23
+    0xffdf79, //24
+    0xffdf88, //25
+    0xffdf98, //26
+    0xffd079, //-5
+    0xffd088, //-4
+    0xffd179, //-3
+    0xffd188, //-2
+    0xffd288, //-1
+    0xffd36c, //0
+    0xffd379, //1
+    0xffd388, //2
+    0xffd479, //3
+    0xffd488, //4
+    0xffd579, //5
+    0xffd588, //6
+    0xffd679, //7
+    0xffd688, //8
+    0xffd779, //9
+    0xffd879, //10
+    //high
+    0xffc879, //8
+    0xffc96b, //9
+    0xffc979, //10
+    0xffca6b, //11
+    0xffca79, //12
+    0xffcc56, //13
+    0xffcc60, //14
+    0xffcc6b, //15
+    0xffcc79, //16
+    0xffcd72, //17
+    0xffce60, //18
+    0xffce72, //19
+    0xffcf72, //20
+    0xffcf80, //21
+    0xffcf90, //22
+    0xffcf90, //23
+    0xffc079, //-8
+    0xffc16b, //-7
+    0xffc179, //-6
+    0xffc26b, //-5
+    0xffc279, //-4
+    0xffc36b, //-3
+    0xffc379, //-2
+    0xffc46b, //-1
+    0xffc479, //0
+    0xffc56b, //1
+    0xffc579, //2
+    0xffc66b, //3
+    0xffc679, //4
+    0xffc76b, //5
+    0xffc779, //6
+    0xffc86b, //7
+    //low
+    0xffc879, //8
+    0xffc96b, //9
+    0xffc979, //10
+    0xffca6b, //11
+    0xffca79, //12
+    0xffcc56, //13
+    0xffcc60, //14
+    0xffcc6b, //15
+    0xffcc79, //16
+    0xffcd72, //17
+    0xffce60, //18
+    0xffce72, //19
+    0xffcf72, //20
+    0xffcf80, //21
+    0xffcf90, //22
+    0xffcf90, //23
+    0xffc079, //-8
+    0xffc16b, //-7
+    0xffc179, //-6
+    0xffc26b, //-5
+    0xffc279, //-4
+    0xffc36b, //-3
+    0xffc379, //-2
+    0xffc46b, //-1
+    0xffc479, //0
+    0xffc56b, //1
+    0xffc579, //2
+    0xffc66b, //3
+    0xffc679, //4
+    0xffc76b, //5
+    0xffc779, //6
+    0xffc86b, //7
+};
+
 u32 patch_tbl_func[][2] =
 {
     {0x00110054, 0x0018186D}, // same as jump_tbl idx 168
@@ -1842,6 +1948,10 @@ u32 adaptivity_patch_tbl[][2] = {
 };
 //adap test
 
+#ifdef CONFIG_DPD
+rf_misc_ram_lite_t dpd_res;
+#endif
+
 int aicwf_patch_table_load(struct rwnx_hw *rwnx_hw, char *filename)
 {
     int err = 0;
@@ -1931,7 +2041,7 @@ void aicwf_patch_config_8800dc(struct rwnx_hw *rwnx_hw)
         u32 patch_tbl_wifisetting_num = sizeof(patch_tbl_wifisetting)/sizeof(u32)/2;
         u32 ldpc_cfg_size = sizeof(ldpc_cfg_ram);
         u32 agc_cfg_size = sizeof(agc_cfg_ram);
-        u32 txgain_cfg_size = sizeof(txgain_map);
+        u32 txgain_cfg_size, *txgain_cfg_array;
 		u32 jump_tbl_size = 0;
 		u32 patch_tbl_func_num = 0;
 
@@ -2030,7 +2140,14 @@ void aicwf_patch_config_8800dc(struct rwnx_hw *rwnx_hw)
         }
 
         #if !defined(CONFIG_FPGA_VERIFICATION)
-        ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, txgain_cfg_addr, txgain_cfg_size, txgain_map);
+        if ((IS_CHIP_ID_H())) {
+            txgain_cfg_size = sizeof(txgain_map_h);
+            txgain_cfg_array = (u32 *)txgain_map_h;
+        } else {
+            txgain_cfg_size = sizeof(txgain_map);
+            txgain_cfg_array = (u32 *)txgain_map;
+        }
+        ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, txgain_cfg_addr, txgain_cfg_size, txgain_cfg_array);
         if (ret) {
             AICWFDBG(LOGERROR, "txgain upload fail: %x, err:%d\r\n", txgain_cfg_addr, ret);
         }
@@ -2047,18 +2164,24 @@ void aicwf_patch_config_8800dc(struct rwnx_hw *rwnx_hw)
 	                AICWFDBG(LOGERROR, "patch_tbl_func %x write fail\n", patch_tbl_func_base[cnt][0]);
 	            }
 	        }
-		}
-		else{
-			ret = aicwf_patch_table_load(rwnx_hw, RWNX_MAC_PATCH_TABLE_8800DC_U02);
-			if(ret){
-				printk("patch_tbl upload fail: err:%d\r\n", ret);
-			}
+        } else if (chip_sub_id == 1) {
+            ret = aicwf_patch_table_load(rwnx_hw, RWNX_MAC_PATCH_TABLE_8800DC_U02);
+            if(ret){
+                printk("patch_tbl upload fail: err:%d\r\n", ret);
+            }
 #ifdef CONFIG_FOR_IPCAM
             if ((ret = rwnx_send_dbg_mem_write_req(rwnx_hw, 0x00111944, 0x00000101))) {
                 AICWFDBG(LOGERROR, "patch_tbl_func %x write fail\n", patch_tbl_func_base[cnt][0]);
             }
 #endif
-		}
+        } else if (chip_sub_id == 2) {
+            ret = aicwf_patch_table_load(rwnx_hw, RWNX_MAC_PATCH_TABLE_8800DC_H_U02);
+            if(ret){
+                printk("patch_tbl upload fail: err:%d\r\n", ret);
+            }
+        } else {
+            printk("unsupported id: %d\n", chip_sub_id);
+        }
 
         #endif
     } else {
@@ -2111,17 +2234,34 @@ int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_c
 			return -1;
 		}
 	} else if (testmode == FW_RFTEST_MODE) {
-        if (chip_sub_id == 1) {
+        if (chip_sub_id >= 1) {
             #ifdef CONFIG_DPD
+            #ifndef CONFIG_FORCE_DPD_CALIB
             if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 1) {
                 AICWFDBG(LOGINFO, "%s load dpd bin\n", __func__);
-                ret = aicwf_dpd_result_load_8800dc(rwnx_hw);
+                ret = aicwf_dpd_result_load_8800dc(rwnx_hw, &dpd_res);
                 if (ret) {
                     AICWFDBG(LOGINFO, "load dpd bin fail: %d\n", ret);
                     return ret;
                 }
             }
             #endif
+            if (dpd_res.bit_mask[1]) {
+                ret = aicwf_dpd_result_apply_8800dc(rwnx_hw, &dpd_res);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "apply dpd bin fail: %d\n", ret);
+                    return ret;
+                }
+            }
+            #else
+            {
+                ret = aicwf_misc_ram_init_8800dc(rwnx_hw);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "misc ram init fail: %d\n", ret);
+                    return ret;
+                }
+            }
+            #endif
             ret = rwnx_send_rf_calib_req(rwnx_hw, cfm);
             if (ret) {
                 AICWFDBG(LOGINFO, "rf calib req fail: %d\n", ret);
@@ -2143,6 +2283,8 @@ int aicwf_plat_patch_load_8800dc(struct rwnx_hw *rwnx_hw)
         ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC);
     } else if (chip_sub_id == 1) {
         ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC_U02);
+    } else if (chip_sub_id == 2) {
+        ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC_H_U02);
     } else {
         printk("unsupported id: %d\n", chip_sub_id);
     }
@@ -2162,6 +2304,74 @@ int aicwf_plat_rftest_load_8800dc(struct rwnx_hw *rwnx_hw)
 }
 
 #ifdef CONFIG_DPD
+int aicwf_misc_ram_valid_check_8800dc(struct rwnx_hw *rwnx_hw, int *valid_out)
+{
+    int ret = 0;
+    uint32_t cfg_base = 0x10164;
+    struct dbg_mem_read_cfm cfm;
+    uint32_t misc_ram_addr;
+    uint32_t ram_base_addr, ram_word_cnt;
+    uint32_t bit_mask[4];
+    int i;
+    if (valid_out) {
+        *valid_out = 0;
+    }
+    if (testmode == FW_RFTEST_MODE) {
+	    uint32_t vect1 = 0;
+	    uint32_t vect2 = 0;
+	    cfg_base = RAM_LMAC_FW_ADDR + 0x0004;
+	    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base, &cfm);
+	    if (ret) {
+		    AICWFDBG(LOGERROR, "cfg_base:%x vcet1 rd fail: %d\n", cfg_base, ret);
+		    return ret;
+	    }
+	    vect1 = cfm.memdata;
+	    if ((vect1 & 0xFFFF0000) != (RAM_LMAC_FW_ADDR & 0xFFFF0000)) {
+		    AICWFDBG(LOGERROR, "vect1 invalid: %x\n", vect1);
+		    return ret;
+	    }
+	    cfg_base = RAM_LMAC_FW_ADDR + 0x0008;
+	    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base, &cfm);
+	    if (ret) {
+		    AICWFDBG(LOGERROR, "cfg_base:%x vcet2 rd fail: %d\n", cfg_base, ret);
+		    return ret;
+	    }
+	    vect2 = cfm.memdata;
+	    if ((vect2 & 0xFFFF0000) != (RAM_LMAC_FW_ADDR & 0xFFFF0000)) {
+		    AICWFDBG(LOGERROR, "vect2 invalid: %x\n", vect2);
+		    return ret;
+	    }
+	    cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
+    }
+    // init misc ram
+    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm);
+    if (ret) {
+        AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
+        return ret;
+    }
+    misc_ram_addr = cfm.memdata;
+    AICWFDBG(LOGERROR, "misc_ram_addr=%x\n", misc_ram_addr);
+    // bit_mask
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, bit_mask);
+    ram_word_cnt = (MEMBER_SIZE(rf_misc_ram_t, bit_mask) + MEMBER_SIZE(rf_misc_ram_t, reserved)) / 4;
+    for (i = 0; i < ram_word_cnt; i++) {
+        ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
+        if (ret) {
+            AICWFDBG(LOGERROR, "bit_mask[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+            return ret;
+        }
+        bit_mask[i] = cfm.memdata;
+    }
+    AICWFDBG(LOGTRACE, "bit_mask:%x,%x,%x,%x\n",bit_mask[0],bit_mask[1],bit_mask[2],bit_mask[3]);
+    if ((bit_mask[0] == 0) && ((bit_mask[1] & 0xFFF00000) == 0x80000000) &&
+        (bit_mask[2] == 0) && ((bit_mask[3] & 0xFFFFFF00) == 0x00000000)) {
+        if (valid_out) {
+            *valid_out = 1;
+        }
+    }
+    return ret;
+}
+
 int aicwf_plat_calib_load_8800dc(struct rwnx_hw *rwnx_hw)
 {
     int ret = 0;
@@ -2171,6 +2381,12 @@ int aicwf_plat_calib_load_8800dc(struct rwnx_hw *rwnx_hw)
             AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
             return ret;
         }
+    } else if (chip_sub_id == 2) {
+        ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_CALIB_ADDR, RWNX_MAC_CALIB_NAME_8800DC_H_U02);
+        if (ret) {
+            AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
+            return ret;
+        }
     }
     return ret;
 }
@@ -2179,11 +2395,14 @@ int aicwf_plat_calib_load_8800dc(struct rwnx_hw *rwnx_hw)
 int aicwf_misc_ram_init_8800dc(struct rwnx_hw *rwnx_hw)
 {
     int ret = 0;
-    const uint32_t cfg_base = 0x10164;
+    uint32_t cfg_base = 0x10164;
     struct dbg_mem_read_cfm cfm;
     uint32_t misc_ram_addr;
     uint32_t misc_ram_size = 12;
     int i;
+    if (testmode == FW_RFTEST_MODE) {
+        cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
+    }
     // init misc ram
     ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm);
     if (ret) {
@@ -2203,10 +2422,20 @@ int aicwf_misc_ram_init_8800dc(struct rwnx_hw *rwnx_hw)
 }
 
 #ifdef CONFIG_DPD
-int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, uint32_t *dpd_res)
+int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res)
 {
     int ret = 0;
     uint32_t fw_addr, boot_type;
+    int valid_flag;
+    ret = aicwf_misc_ram_valid_check_8800dc(rwnx_hw, &valid_flag);
+    if (ret) {
+        AICWFDBG(LOGINFO, "misc ram check fail: %d\n", ret);
+        return ret;
+    }
+    if (valid_flag) {
+        AICWFDBG(LOGINFO, "misc ram valid, skip calib process\n");
+        return ret;
+    }
     ret = aicwf_plat_calib_load_8800dc(rwnx_hw);
     if (ret) {
         AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
@@ -2225,7 +2454,7 @@ int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, uint32_t *dpd_res)
         const uint32_t cfg_base = 0x10164;
         struct dbg_mem_read_cfm cfm;
         uint32_t misc_ram_addr;
-        uint32_t misc_ram_size = DPD_RESULT_SIZE_8800DC;
+        uint32_t ram_base_addr, ram_word_cnt;
         int i;
         ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm);
         if (ret) {
@@ -2233,53 +2462,130 @@ int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, uint32_t *dpd_res)
             return ret;
         }
         misc_ram_addr = cfm.memdata;
-        for (i = 0; i < (misc_ram_size / 4); i++) {
-            ret = rwnx_send_dbg_mem_read_req(rwnx_hw, misc_ram_addr + i * 4, &cfm);
+        // bit_mask
+        ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, bit_mask);
+        ram_word_cnt = (MEMBER_SIZE(rf_misc_ram_t, bit_mask) + MEMBER_SIZE(rf_misc_ram_t, reserved)) / 4;
+        for (i = 0; i < ram_word_cnt; i++) {
+            ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
+            if (ret) {
+                AICWFDBG(LOGERROR, "bit_mask[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+                return ret;
+            }
+            dpd_res->bit_mask[i] = cfm.memdata;
+        }
+        // dpd_high
+        ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, dpd_high);
+        ram_word_cnt = MEMBER_SIZE(rf_misc_ram_t, dpd_high) / 4;
+        for (i = 0; i < ram_word_cnt; i++) {
+            ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
+            if (ret) {
+                AICWFDBG(LOGERROR, "bit_mask[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+                return ret;
+            }
+            dpd_res->dpd_high[i] = cfm.memdata;
+        }
+        // loft_res
+        ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, loft_res);
+        ram_word_cnt = MEMBER_SIZE(rf_misc_ram_t, loft_res) / 4;
+        for (i = 0; i < ram_word_cnt; i++) {
+            ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
             if (ret) {
-                AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n",  misc_ram_addr + i * 4, ret);
+                AICWFDBG(LOGERROR, "bit_mask[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
                 return ret;
             }
-            dpd_res[i] = cfm.memdata;
+            dpd_res->loft_res[i] = cfm.memdata;
         }
     }
     return ret;
 }
 
-int aicwf_dpd_result_load_8800dc(struct rwnx_hw *rwnx_hw)
+int aicwf_dpd_result_apply_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res)
 {
     int ret = 0;
     uint32_t cfg_base = 0x10164;
     struct dbg_mem_read_cfm cfm;
     uint32_t misc_ram_addr;
-	if (testmode == FW_RFTEST_MODE) {
-		cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
-	}
+    uint32_t ram_base_addr, ram_byte_cnt;
+    AICWFDBG(LOGINFO, "bit_mask[1]=%x\n", dpd_res->bit_mask[1]);
+    if (dpd_res->bit_mask[1] == 0) {
+        AICWFDBG(LOGERROR, "void dpd_res, bypass it.\n");
+        return 0;
+    }
+    if (testmode == FW_RFTEST_MODE) {
+        cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
+    }
     if ((ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm))) {
         AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
         return ret;
     }
     misc_ram_addr = cfm.memdata;
     AICWFDBG(LOGINFO, "misc_ram_addr: %x\n", misc_ram_addr);
-    ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, misc_ram_addr, FW_DPDRESULT_NAME_8800DC);
+    /* Copy dpd_res on the Embedded side */
+    // bit_mask
+    AICWFDBG(LOGINFO, "bit_mask[0]=%x\n", dpd_res->bit_mask[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, bit_mask);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, bit_mask) + MEMBER_SIZE(rf_misc_ram_t, reserved);
+    ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, ram_base_addr, ram_byte_cnt, (u32 *)&dpd_res->bit_mask[0]);
     if (ret) {
-        AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
+        AICWFDBG(LOGERROR, "bit_mask wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
+        return ret;
+    }
+    // dpd_high
+    AICWFDBG(LOGINFO, "dpd_high[0]=%x\n", dpd_res->dpd_high[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, dpd_high);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, dpd_high);
+    ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, ram_base_addr, ram_byte_cnt, (u32 *)&dpd_res->dpd_high[0]);
+    if (ret) {
+        AICWFDBG(LOGERROR, "dpd_high wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
+        return ret;
+    }
+    // loft_res
+    AICWFDBG(LOGINFO, "loft_res[0]=%x\n", dpd_res->loft_res[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, loft_res);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, loft_res);
+    ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, ram_base_addr, ram_byte_cnt, (u32 *)&dpd_res->loft_res[0]);
+    if (ret) {
+        AICWFDBG(LOGERROR, "loft_res wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
         return ret;
     }
     return ret;
 }
 
+#ifndef CONFIG_FORCE_DPD_CALIB
+int aicwf_dpd_result_load_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res)
+{
+    int ret = 0;
+    int size;
+    u32 *dst=NULL;
+    char *filename = FW_DPDRESULT_NAME_8800DC;
+    AICWFDBG(LOGINFO, "dpd_res file path:%s \r\n", filename);
+    /* load file */
+    size = rwnx_request_firmware_common(rwnx_hw, &dst, filename);
+    if (size <= 0) {
+        AICWFDBG(LOGERROR, "wrong size of dpd_res file\n");
+        dst = NULL;
+        return -1;
+    }
+    AICWFDBG(LOGINFO, "### Load file done: %s, size=%d, dst[0]=%x\n", filename, size, dst[0]);
+    memcpy((u8 *)dpd_res, (u8 *)dst, sizeof(rf_misc_ram_lite_t));
+    if (dst) {
+        rwnx_release_firmware_common(&dst);
+    }
+    return ret;
+}
+
 #define FW_PATH_MAX_LEN 200
 extern char aic_fw_path[FW_PATH_MAX_LEN];
 
 int aicwf_dpd_result_write_8800dc(void *buf, int buf_len)
 {
-	AICWFDBG(LOGINFO, "%s\n", __func__);
     int sum = 0, len = 0;
     char *path = NULL;
     struct file *fp = NULL;
     loff_t pos = 0;
     mm_segment_t fs;
 
+	AICWFDBG(LOGINFO, "%s\n", __func__);
     path = __getname();
     if (!path) {
         AICWFDBG(LOGINFO, "get path fail\n");
@@ -2314,6 +2620,7 @@ int aicwf_dpd_result_write_8800dc(void *buf, int buf_len)
 
     return 0;
 }
+#endif /* !CONFIG_FORCE_DPD_CALIB */
 #endif
 
 int	rwnx_plat_userconfig_load_8800dc(struct rwnx_hw *rwnx_hw){
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h
index 9730a8137950..1939bda48147 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h
@@ -1,16 +1,45 @@
 #include <linux/types.h>
 
-#define DPD_RESULT_SIZE_8800DC 1880
+#ifdef CONFIG_DPD
+typedef struct {
+    uint32_t bit_mask[3];
+    uint32_t reserved;
+    uint32_t dpd_high[96];
+    uint32_t dpd_11b[96];
+    uint32_t dpd_low[96];
+    uint32_t idac_11b[48];
+    uint32_t idac_high[48];
+    uint32_t idac_low[48];
+    uint32_t loft_res[18];
+    uint32_t rx_iqim_res[16];
+} rf_misc_ram_t;
+
+typedef struct {
+    uint32_t bit_mask[4];
+    uint32_t dpd_high[96];
+    uint32_t loft_res[18];
+} rf_misc_ram_lite_t;
+
+#define MEMBER_SIZE(type, member)   sizeof(((type *)0)->member)
+#define DPD_RESULT_SIZE_8800DC      sizeof(rf_misc_ram_lite_t)
+
+extern rf_misc_ram_lite_t dpd_res;
+#endif
+
 int aicwf_patch_table_load(struct rwnx_hw *rwnx_hw, char *filename);
 void aicwf_patch_config_8800dc(struct rwnx_hw *rwnx_hw);
 int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *cfm);
 int aicwf_misc_ram_init_8800dc(struct rwnx_hw *rwnx_hw);
 #ifdef CONFIG_DPD
+int aicwf_misc_ram_valid_check_8800dc(struct rwnx_hw *rwnx_hw, int *valid_out);
 int aicwf_plat_calib_load_8800dc(struct rwnx_hw *rwnx_hw);
-int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, uint32_t *dpd_res);
-int aicwf_dpd_result_load_8800dc(struct rwnx_hw *rwnx_hw);
+int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res);
+int aicwf_dpd_result_apply_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res);
+#ifndef CONFIG_FORCE_DPD_CALIB
+int aicwf_dpd_result_load_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res);
 int aicwf_dpd_result_write_8800dc(void *buf, int buf_len);
 #endif
+#endif
 int aicwf_plat_patch_load_8800dc(struct rwnx_hw *rwnx_hw);
 int aicwf_plat_rftest_load_8800dc(struct rwnx_hw *rwnx_hw);
 int	rwnx_plat_userconfig_load_8800dc(struct rwnx_hw *rwnx_hw);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h
index a19bbe9a4578..dc805a53d9a3 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h
@@ -24,4 +24,4 @@ extern int aicwf_prealloc_init(void);
 extern void aicwf_prealloc_exit(void);
 extern int aicwf_rxbuff_size_get(void);
 #endif
-#endif /* _AICWF_RX_PREALLOC_H_ */
\ No newline at end of file
+#endif /* _AICWF_RX_PREALLOC_H_ */
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c
new file mode 100644
index 000000000000..2ad2b19312ff
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c
@@ -0,0 +1,633 @@
+#include"aicwf_tcp_ack.h"
+//#include"rwnx_tx.h"
+//#include "aicwf_tcp_ack.h"
+#include"rwnx_defs.h"
+extern int intf_tx(struct rwnx_hw *priv,struct msg_buf *msg);
+struct msg_buf *intf_tcp_alloc_msg(struct msg_buf *msg)
+{
+	//printk("%s \n",__func__);
+	int len=sizeof(struct msg_buf) ;
+	msg = kzalloc(len , GFP_ATOMIC);
+	if(!msg)
+		printk("%s: alloc failed \n", __func__);
+	memset(msg,0,len);
+	return msg;
+}
+						
+void intf_tcp_drop_msg(struct rwnx_hw *priv,
+					    struct msg_buf *msg)
+{
+	//printk("%s \n",__func__);
+	if (msg->skb)
+		dev_kfree_skb_any(msg->skb);
+
+	kfree(msg);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0) 
+void tcp_ack_timeout(unsigned long data)
+#else
+void tcp_ack_timeout(struct timer_list *t)
+#endif
+{
+	//printk("%s \n",__func__);
+	struct tcp_ack_info *ack_info;
+	struct msg_buf *msg;
+	struct tcp_ack_manage *ack_m = NULL;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0) 
+	ack_info = (struct tcp_ack_info *)data;
+#else
+	ack_info = container_of(t,struct tcp_ack_info,timer);
+#endif
+
+	ack_m = container_of(ack_info, struct tcp_ack_manage,
+			     ack_info[ack_info->ack_info_num]);
+
+	write_seqlock_bh(&ack_info->seqlock);
+	msg = ack_info->msgbuf;
+	if (ack_info->busy && msg && !ack_info->in_send_msg) {
+		ack_info->msgbuf = NULL;
+		ack_info->drop_cnt = 0;
+		ack_info->in_send_msg = msg;
+		write_sequnlock_bh(&ack_info->seqlock);
+		intf_tx(ack_m->priv, msg);//send skb
+		//ack_info->in_send_msg = NULL;//add by dwx
+		//write_sequnlock_bh(&ack_info->seqlock);
+		//intf_tx(ack_m->priv, msg);
+		return;
+	}
+	write_sequnlock_bh(&ack_info->seqlock);
+}
+
+void tcp_ack_init(struct rwnx_hw *priv)
+{
+	int i;
+	struct tcp_ack_info *ack_info;
+	struct tcp_ack_manage *ack_m = &priv->ack_m;
+
+	printk("========== tcp ack debug %s \n",__func__);
+	memset(ack_m, 0, sizeof(struct tcp_ack_manage));
+	ack_m->priv = priv;
+	spin_lock_init(&ack_m->lock);
+	atomic_set(&ack_m->max_drop_cnt, TCP_ACK_DROP_CNT);
+	ack_m->last_time = jiffies;
+	ack_m->timeout = msecs_to_jiffies(ACK_OLD_TIME);
+
+	for (i = 0; i < TCP_ACK_NUM; i++) {
+		ack_info = &ack_m->ack_info[i];
+		ack_info->ack_info_num = i;
+		seqlock_init(&ack_info->seqlock);
+		ack_info->last_time = jiffies;
+		ack_info->timeout = msecs_to_jiffies(ACK_OLD_TIME);
+
+		#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0) 
+			setup_timer(&ack_info->timer, tcp_ack_timeout,
+				    (unsigned long)ack_info);
+		#else
+			timer_setup(&ack_info->timer,tcp_ack_timeout,0);
+		#endif
+	}
+
+	atomic_set(&ack_m->enable, 1);
+	ack_m->ack_winsize = MIN_WIN;
+}
+
+void tcp_ack_deinit(struct rwnx_hw *priv)
+{
+	int i;
+	struct tcp_ack_manage *ack_m = &priv->ack_m;
+	struct msg_buf *drop_msg = NULL;
+
+	printk("%s \n",__func__);
+	atomic_set(&ack_m->enable, 0);
+
+	for (i = 0; i < TCP_ACK_NUM; i++) {
+		drop_msg = NULL;
+
+		write_seqlock_bh(&ack_m->ack_info[i].seqlock);
+		del_timer(&ack_m->ack_info[i].timer);
+		drop_msg = ack_m->ack_info[i].msgbuf;
+		ack_m->ack_info[i].msgbuf = NULL;
+		write_sequnlock_bh(&ack_m->ack_info[i].seqlock);
+
+		if (drop_msg)
+			intf_tcp_drop_msg(priv, drop_msg);//drop skb
+	}
+}
+
+int tcp_check_quick_ack(unsigned char *buf,
+				      struct tcp_ack_msg *msg)
+{
+	int ip_hdr_len;
+	unsigned char *temp;
+	struct ethhdr *ethhdr;
+	struct iphdr *iphdr;
+	struct tcphdr *tcphdr;
+
+	ethhdr = (struct ethhdr *)buf;
+	if (ethhdr->h_proto != htons(ETH_P_IP))
+		return 0;
+	iphdr = (struct iphdr *)(ethhdr + 1);
+	if (iphdr->version != 4 || iphdr->protocol != IPPROTO_TCP)
+		return 0;
+	ip_hdr_len = iphdr->ihl * 4;
+	temp = (unsigned char *)(iphdr) + ip_hdr_len;
+	tcphdr = (struct tcphdr *)temp;
+	/* TCP_FLAG_ACK */
+	if (!(temp[13] & 0x10))
+		return 0;
+
+	if (temp[13] & 0x8) {
+		msg->saddr = iphdr->daddr;
+		msg->daddr = iphdr->saddr;
+		msg->source = tcphdr->dest;
+		msg->dest = tcphdr->source;
+		msg->seq = ntohl(tcphdr->seq);
+		return 1;
+	}
+
+	return 0;
+}
+
+int is_drop_tcp_ack(struct tcphdr *tcphdr, int tcp_tot_len,
+				unsigned short *win_scale)
+{
+	//printk("%s \n",__func__);
+	int drop = 1;
+	int len = tcphdr->doff * 4;
+	unsigned char *ptr;
+
+	if(tcp_tot_len > len) {
+		drop = 0;
+	} else {
+		len -= sizeof(struct tcphdr);
+		ptr = (unsigned char *)(tcphdr + 1);
+
+		while ((len > 0) && drop) {
+			int opcode = *ptr++;
+			int opsize;
+
+			switch (opcode) {
+			case TCPOPT_EOL:
+				break;
+			case TCPOPT_NOP:
+				len--;
+				continue;
+			default:
+				opsize = *ptr++;
+				if (opsize < 2)
+					break;
+				if (opsize > len)
+					break;
+
+				switch (opcode) {
+				/* TODO: Add other ignore opt */
+				case TCPOPT_TIMESTAMP:
+					break;
+				case TCPOPT_WINDOW:
+					if (*ptr < 15)
+						*win_scale = (1 << (*ptr));
+					printk("%d\n",*win_scale);
+					break;
+				default:
+					drop = 2;
+				}
+
+				ptr += opsize - 2;
+				len -= opsize;
+			}
+		}
+	}
+
+	return drop;
+}
+
+
+/* flag:0 for not tcp ack
+ *	1 for ack which can be drop
+ *	2 for other ack whith more info
+ */
+
+int tcp_check_ack(unsigned char *buf,
+				struct tcp_ack_msg *msg,
+				unsigned short *win_scale)
+{
+	int ret;
+	int ip_hdr_len;
+	int tcp_tot_len;
+	unsigned char *temp;
+	struct ethhdr *ethhdr;
+	struct iphdr *iphdr;
+	struct tcphdr *tcphdr;
+
+	ethhdr =(struct ethhdr *)buf;
+	if (ethhdr->h_proto != htons(ETH_P_IP))
+		return 0;
+
+	iphdr = (struct iphdr *)(ethhdr + 1);
+	if (iphdr->version != 4 || iphdr->protocol != IPPROTO_TCP)
+		return 0;
+
+	ip_hdr_len = iphdr->ihl * 4;
+	temp = (unsigned char *)(iphdr) + ip_hdr_len;
+	tcphdr = (struct tcphdr *)temp;
+	/* TCP_FLAG_ACK */
+	if (!(temp[13] & 0x10))
+		return 0;
+
+	tcp_tot_len = ntohs(iphdr->tot_len) - ip_hdr_len;// tcp total len
+	ret = is_drop_tcp_ack(tcphdr, tcp_tot_len, win_scale);
+	//printk("is drop:%d \n",ret);
+
+	if (ret > 0) {
+		msg->saddr = iphdr->saddr;
+		msg->daddr = iphdr->daddr;
+		msg->source = tcphdr->source;
+		msg->dest = tcphdr->dest;
+		msg->seq = ntohl(tcphdr->ack_seq);
+		msg->win = ntohs(tcphdr->window);
+	}
+	
+	return ret;
+}
+
+/* return val: -1 for not match, others for match */
+int tcp_ack_match(struct tcp_ack_manage *ack_m,
+				struct tcp_ack_msg *ack_msg)
+{
+	int i, ret = -1;
+	unsigned start;
+	struct tcp_ack_info *ack_info;
+	struct tcp_ack_msg *ack;
+
+	for (i = 0; ((ret < 0) && (i < TCP_ACK_NUM)); i++) {
+		ack_info = &ack_m->ack_info[i];
+		do {
+			start = read_seqbegin(&ack_info->seqlock);
+			ret = -1;
+
+			ack = &ack_info->ack_msg;
+			if (ack_info->busy &&
+			    ack->dest == ack_msg->dest &&
+			    ack->source == ack_msg->source &&
+			    ack->saddr == ack_msg->saddr &&
+			    ack->daddr == ack_msg->daddr)
+				ret = i;
+		} while(read_seqretry(&ack_info->seqlock, start));
+	}
+
+	return ret;
+}
+
+
+void tcp_ack_update(struct tcp_ack_manage *ack_m)
+{
+	int i;
+	struct tcp_ack_info *ack_info;
+
+	if (time_after(jiffies, ack_m->last_time + ack_m->timeout)) {
+		spin_lock_bh(&ack_m->lock);
+		ack_m->last_time = jiffies;
+		for (i = TCP_ACK_NUM - 1; i >= 0; i--) {
+			ack_info = &ack_m->ack_info[i];
+			write_seqlock_bh(&ack_info->seqlock);
+			if (ack_info->busy &&
+			    time_after(jiffies, ack_info->last_time +
+				       ack_info->timeout)) {
+				ack_m->free_index = i;
+				ack_m->max_num--;
+				ack_info->busy = 0;
+			}
+			write_sequnlock_bh(&ack_info->seqlock);
+		}
+		spin_unlock_bh(&ack_m->lock);
+	}
+}
+
+/* return val: -1 for no index, others for index */
+int tcp_ack_alloc_index(struct tcp_ack_manage *ack_m)
+{
+	int i, ret = -1;
+	struct tcp_ack_info *ack_info;
+	unsigned start;
+
+	spin_lock_bh(&ack_m->lock);
+	if (ack_m->max_num == TCP_ACK_NUM) {
+		spin_unlock_bh(&ack_m->lock);
+		return -1;
+	}
+
+	if (ack_m->free_index >= 0) {
+		i = ack_m->free_index;
+		ack_m->free_index = -1;
+		ack_m->max_num++;
+		spin_unlock_bh(&ack_m->lock);
+		return i;
+	}
+
+	for (i = 0; ((ret < 0) && (i < TCP_ACK_NUM)); i++) {
+		ack_info = &ack_m->ack_info[i];
+		do {
+			start = read_seqbegin(&ack_info->seqlock);
+			ret = -1;
+			if (!ack_info->busy) {
+				ack_m->free_index = -1;
+				ack_m->max_num++;
+				ret = i;
+			}
+		} while(read_seqretry(&ack_info->seqlock, start));
+	}
+	spin_unlock_bh(&ack_m->lock);
+
+	return ret;
+}
+
+
+/* return val: 0 for not handle tx, 1 for handle tx */
+int tcp_ack_handle(struct msg_buf *new_msgbuf,
+			  struct tcp_ack_manage *ack_m,
+			  struct tcp_ack_info *ack_info,
+			  struct tcp_ack_msg *ack_msg,
+			  int type)
+{
+	int quick_ack = 0;
+	struct tcp_ack_msg *ack;
+	int ret = 0;
+	struct msg_buf *drop_msg = NULL;
+
+	//printk("%s %d",__func__,type);
+	write_seqlock_bh(&ack_info->seqlock);
+
+	ack_info->last_time = jiffies;
+	ack = &ack_info->ack_msg;
+
+	if (type == 2) {
+		if (U32_BEFORE(ack->seq, ack_msg->seq)) {
+			ack->seq = ack_msg->seq;
+			if (ack_info->psh_flag &&
+			    !U32_BEFORE(ack_msg->seq,
+					       ack_info->psh_seq)) {
+				ack_info->psh_flag = 0;
+			}
+
+			if (ack_info->msgbuf) {
+				//printk("%lx \n",ack_info->msgbuf);
+				drop_msg = ack_info->msgbuf;
+				ack_info->msgbuf = NULL;
+				del_timer(&ack_info->timer);
+			}else{
+				//printk("msgbuf is NULL \n");
+			}
+
+			ack_info->in_send_msg = NULL;
+			ack_info->drop_cnt = atomic_read(&ack_m->max_drop_cnt);
+		} else {
+			printk("%s before abnormal ack: %d, %d\n",
+			       __func__, ack->seq, ack_msg->seq);
+			drop_msg = new_msgbuf;
+			ret = 1;
+		}
+	} else if (U32_BEFORE(ack->seq, ack_msg->seq)) {
+		if (ack_info->msgbuf) {
+			drop_msg = ack_info->msgbuf;
+			ack_info->msgbuf = NULL;
+		}
+
+		if (ack_info->psh_flag &&
+		    !U32_BEFORE(ack_msg->seq, ack_info->psh_seq)) {
+			ack_info->psh_flag = 0;
+			quick_ack = 1;
+		} else {
+			ack_info->drop_cnt++;
+		}
+
+		ack->seq = ack_msg->seq;
+
+		if (quick_ack || (!ack_info->in_send_msg &&
+				  (ack_info->drop_cnt >=
+				   atomic_read(&ack_m->max_drop_cnt)))) {
+			ack_info->drop_cnt = 0;
+			ack_info->in_send_msg = new_msgbuf;
+			del_timer(&ack_info->timer);
+		} else {
+			ret = 1;
+			ack_info->msgbuf = new_msgbuf;
+			if (!timer_pending(&ack_info->timer))
+				mod_timer(&ack_info->timer,
+					  (jiffies + msecs_to_jiffies(5)));
+		}
+	} else {
+		printk("%s before ack: %d, %d\n",
+		       __func__, ack->seq, ack_msg->seq);
+		drop_msg = new_msgbuf;
+		ret = 1;
+	}
+
+	write_sequnlock_bh(&ack_info->seqlock);
+
+	if (drop_msg)
+		intf_tcp_drop_msg(ack_m->priv, drop_msg);// drop skb
+
+	return ret;
+}
+
+int tcp_ack_handle_new(struct msg_buf *new_msgbuf,
+			  struct tcp_ack_manage *ack_m,
+			  struct tcp_ack_info *ack_info,
+			  struct tcp_ack_msg *ack_msg,
+			  int type)
+{
+	int quick_ack = 0;
+	struct tcp_ack_msg *ack;
+	int ret = 0;
+	struct msg_buf *drop_msg = NULL;
+	struct msg_buf * send_msg = NULL;
+	//printk("",);
+	write_seqlock_bh(&ack_info->seqlock);
+
+        ack_info->last_time = jiffies;
+        ack = &ack_info->ack_msg;
+
+	if(U32_BEFORE(ack->seq, ack_msg->seq)){
+		if (ack_info->msgbuf) {
+			drop_msg = ack_info->msgbuf;
+			ack_info->msgbuf = NULL;
+			//ack_info->drop_cnt++;
+		}
+
+		if (ack_info->psh_flag &&
+		    !U32_BEFORE(ack_msg->seq, ack_info->psh_seq)) {
+			ack_info->psh_flag = 0;
+			quick_ack = 1;
+		} else {
+			ack_info->drop_cnt++;
+		}
+
+		ack->seq = ack_msg->seq;
+
+		if(quick_ack || (!ack_info->in_send_msg &&
+				  (ack_info->drop_cnt >=
+				   atomic_read(&ack_m->max_drop_cnt)))){
+			ack_info->drop_cnt = 0;
+			send_msg = new_msgbuf;
+			ack_info->in_send_msg = send_msg;
+			del_timer(&ack_info->timer);
+		}else{
+			ret = 1;
+			ack_info->msgbuf = new_msgbuf;
+			if (!timer_pending(&ack_info->timer))
+				mod_timer(&ack_info->timer,
+					  (jiffies + msecs_to_jiffies(5)));
+		}
+		
+		//ret = 1;
+	}else {
+		printk("%s before ack: %d, %d\n",
+		       __func__, ack->seq, ack_msg->seq);
+		drop_msg = new_msgbuf;
+		ret = 1;
+	}
+
+	/*if(send_msg){
+		intf_tx(ack_m->priv,send_msg);
+		ack_info->in_send_msg=NULL;
+	}*/
+
+	//ack_info->in_send_msg=NULL;
+	
+	write_sequnlock_bh(&ack_info->seqlock);
+
+    	/*if(send_msg){
+            intf_tx(ack_m->priv,send_msg);
+            //ack_info->in_send_msg=NULL;
+    	}*/
+
+	if (drop_msg)
+		intf_tcp_drop_msg(ack_m->priv, drop_msg);// drop skb
+
+	return ret;
+
+}
+
+void filter_rx_tcp_ack(struct rwnx_hw *priv,
+			      unsigned char *buf, unsigned plen)
+{
+	int index;
+	struct tcp_ack_msg ack_msg;
+	struct tcp_ack_info *ack_info;
+	struct tcp_ack_manage *ack_m = &priv->ack_m;
+
+	if (!atomic_read(&ack_m->enable))
+		return;
+
+	if ((plen > MAX_TCP_ACK) ||
+	    !tcp_check_quick_ack(buf, &ack_msg))
+		return;
+
+	index = tcp_ack_match(ack_m, &ack_msg);
+	if (index >= 0) {
+		ack_info = ack_m->ack_info + index;
+		write_seqlock_bh(&ack_info->seqlock);
+		ack_info->psh_flag = 1;
+		ack_info->psh_seq = ack_msg.seq;
+		write_sequnlock_bh(&ack_info->seqlock);
+	}
+}
+
+/* return val: 0 for not filter, 1 for filter */
+int filter_send_tcp_ack(struct rwnx_hw *priv,
+			       struct msg_buf *msgbuf,
+			       unsigned char *buf, unsigned int plen)
+{
+//	printk("%s \n",__func__);
+	int ret = 0;
+	int index, drop;
+	unsigned short win_scale = 0;
+	unsigned int win = 0;
+	struct tcp_ack_msg ack_msg;
+	struct tcp_ack_msg *ack;
+	struct tcp_ack_info *ack_info;
+	struct tcp_ack_manage *ack_m = &priv->ack_m;
+
+	if (plen > MAX_TCP_ACK)
+		return 0;
+
+	tcp_ack_update(ack_m);
+	drop = tcp_check_ack(buf, &ack_msg, &win_scale);
+//	printk("drop:%d win_scale:%d",drop,win_scale);
+	if (!drop && (0 == win_scale))
+		return 0;
+
+	index = tcp_ack_match(ack_m, &ack_msg);
+	if (index >= 0) {
+		ack_info = ack_m->ack_info + index;
+		if ((0 != win_scale) &&
+			(ack_info->win_scale != win_scale)) {
+			write_seqlock_bh(&ack_info->seqlock);
+			ack_info->win_scale = win_scale;
+			write_sequnlock_bh(&ack_info->seqlock);
+		}
+
+		if (drop > 0 && atomic_read(&ack_m->enable)) {
+			win = ack_info->win_scale * ack_msg.win;
+			if ((win_scale!=0) && (win < (ack_m->ack_winsize * SIZE_KB)))
+			{	
+				drop = 2;
+				printk("%d %d %d",win_scale,win,(ack_m->ack_winsize * SIZE_KB));
+			}
+			ret = tcp_ack_handle_new(msgbuf, ack_m, ack_info,
+						&ack_msg, drop);
+		}
+
+		goto out;
+	}
+
+	index = tcp_ack_alloc_index(ack_m);
+	if (index >= 0) {
+		write_seqlock_bh(&ack_m->ack_info[index].seqlock);
+		ack_m->ack_info[index].busy = 1;
+		ack_m->ack_info[index].psh_flag = 0;
+		ack_m->ack_info[index].last_time = jiffies;
+		ack_m->ack_info[index].drop_cnt =
+			atomic_read(&ack_m->max_drop_cnt);
+		ack_m->ack_info[index].win_scale =
+			(win_scale != 0) ? win_scale : 1;
+		
+		//ack_m->ack_info[index].msgbuf = NULL;
+		//ack_m->ack_info[index].in_send_msg = NULL;
+		ack = &ack_m->ack_info[index].ack_msg;
+		ack->dest = ack_msg.dest;
+		ack->source = ack_msg.source;
+		ack->saddr = ack_msg.saddr;
+		ack->daddr = ack_msg.daddr;
+		ack->seq = ack_msg.seq;
+		write_sequnlock_bh(&ack_m->ack_info[index].seqlock);
+	}
+
+out:
+	return ret;
+}
+
+void move_tcpack_msg(struct rwnx_hw *priv,
+			    struct msg_buf *msg)
+{
+	struct tcp_ack_info *ack_info;
+	struct tcp_ack_manage *ack_m = &priv->ack_m;
+	int i = 0;
+
+	if (!atomic_read(&ack_m->enable))
+		return;
+
+	//if (msg->len > MAX_TCP_ACK)
+	//	return;
+
+	for (i = 0; i < TCP_ACK_NUM; i++) {
+		ack_info = &ack_m->ack_info[i];
+		write_seqlock_bh(&ack_info->seqlock);
+		if (ack_info->busy && (ack_info->in_send_msg == msg))
+			ack_info->in_send_msg = NULL;
+		write_sequnlock_bh(&ack_info->seqlock);
+	}
+}
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h
new file mode 100644
index 000000000000..ff7f11d9103d
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h
@@ -0,0 +1,111 @@
+#ifndef _AICWF_TCP_ACK_H_
+#define _AICWF_TCP_ACK_H_
+
+#include <uapi/linux/if_ether.h>
+#include <uapi/linux/tcp.h>
+#include <uapi/linux/ip.h>
+#include <uapi/linux/in.h>
+#include <linux/moduleparam.h>
+#include <net/tcp.h>
+#include <linux/timer.h>
+
+
+#define TCP_ACK_NUM  32
+#define TCP_ACK_EXIT_VAL		0x800
+#define TCP_ACK_DROP_CNT		10
+
+#define ACK_OLD_TIME	4000
+#define U32_BEFORE(a, b)	((__s32)((__u32)a - (__u32)b) <= 0)
+
+#define MAX_TCP_ACK 200
+/*min window size in KB, it's 256KB*/
+#define MIN_WIN 256
+#define SIZE_KB 1024
+
+
+struct msg_buf {
+	//struct list_head list;
+	struct sk_buff *skb;
+	struct rwnx_vif *rwnx_vif;
+
+	/* data just tx cmd use,not include the head */
+	/*void *data;
+	void *tran_data;
+	unsigned long pcie_addr;
+	u8 type;
+	u8 mode;
+	u16 len;
+	unsigned long timeout;*/
+	/* marlin 2 */
+	/*unsigned int fifo_id;
+	struct sprdwl_msg_list *msglist;*/
+	/* marlin 3 */
+	/*unsigned char buffer_type;
+	struct sprdwl_xmit_msg_list *xmit_msg_list;
+	unsigned char msg_type;
+
+	unsigned long last_time;
+	u8 ctxt_id;*/
+
+};
+
+struct tcp_ack_msg {
+	u16 source;
+	u16 dest;
+	s32 saddr;
+	s32 daddr;
+	u32 seq;
+	u16 win;
+};
+
+
+struct tcp_ack_info {
+	int ack_info_num;
+	int busy;
+	int drop_cnt;
+	int psh_flag;
+	u32 psh_seq;
+	u16 win_scale;
+	/* seqlock for ack info */
+	seqlock_t seqlock;
+	unsigned long last_time;
+	unsigned long timeout;
+	struct timer_list timer;
+	struct msg_buf *msgbuf;
+	struct msg_buf *in_send_msg;
+	struct tcp_ack_msg ack_msg;
+};
+
+struct tcp_ack_manage {
+	/* 1 filter */
+	atomic_t enable;
+	int max_num;
+	int free_index;
+	unsigned long last_time;
+	unsigned long timeout;
+	atomic_t max_drop_cnt;
+	/* lock for tcp ack alloc and free */
+	spinlock_t lock;
+	struct rwnx_hw *priv;
+	struct tcp_ack_info ack_info[TCP_ACK_NUM];
+	/*size in KB*/
+	unsigned int ack_winsize;
+};
+
+struct msg_buf *intf_tcp_alloc_msg(struct msg_buf *msg);
+
+void tcp_ack_init(struct rwnx_hw *priv);
+
+void tcp_ack_deinit(struct rwnx_hw *priv);
+
+
+int is_drop_tcp_ack(struct tcphdr *tcphdr, int tcp_tot_len, unsigned short *win_scale);
+
+int is_tcp_ack(struct sk_buff *skb, unsigned short *win_scale);
+
+int filter_send_tcp_ack(struct rwnx_hw *priv, struct msg_buf *msgbuf,unsigned char *buf, unsigned int plen);
+
+void filter_rx_tcp_ack(struct rwnx_hw *priv,unsigned char *buf, unsigned plen);
+
+void move_tcpack_msg(struct rwnx_hw *priv, struct msg_buf * msg);
+#endif
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
index 330671ec176b..2b9ebf4bf591 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
@@ -761,7 +761,7 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
 	            else
 	                adjust_len = aggr_len;
 
-	            msg = kmalloc(aggr_len+4, GFP_KERNEL);
+	            msg = kmalloc(aggr_len+4, GFP_KERNEL);//hdr(4)+config(aggrlen)
 	            if(msg == NULL){
 	                txrx_err("no more space for msg!\n");
 	                aicwf_dev_skb_free(skb);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
index 9f76f637f0ce..9d881140d6fe 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
@@ -8,6 +8,7 @@
 
 #include <linux/usb.h>
 #include <linux/kthread.h>
+#include <linux/vmalloc.h>
 #include "aicwf_txrxif.h"
 #include "aicwf_usb.h"
 #include "rwnx_tx.h"
@@ -35,7 +36,7 @@ extern atomic_t aicwf_deinit_atomic;
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
 #include "uapi/linux/sched/types.h"
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0))
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0))
 #include "linux/sched/types.h"
 #else
 #include "linux/sched/rt.h"
@@ -545,6 +546,7 @@ static int aicwf_usb_submit_rx_urb(struct aic_usb_dev *usb_dev,
         aicwf_usb_rx_buf_put(usb_dev, usb_buf);
 
         msleep(100);
+	    return -1;
     }else{
     	atomic_inc(&rx_urb_cnt);
 	}
@@ -596,7 +598,7 @@ static int aicwf_usb_submit_rx_urb(struct aic_usb_dev *usb_dev,
         aicwf_usb_rx_buf_put(usb_dev, usb_buf);
 
         msleep(100);
-	return -1;
+	    return -1;
     }else{
     	atomic_inc(&rx_urb_cnt);
 	}
@@ -617,12 +619,15 @@ static void aicwf_usb_rx_submit_all_urb(struct aic_usb_dev *usb_dev)
     while((usb_buf = aicwf_usb_rx_buf_get(usb_dev)) != NULL) {
         if (aicwf_usb_submit_rx_urb(usb_dev, usb_buf)) {
             AICWFDBG(LOGERROR, "sub rx fail\n");
-				break;
+		return;
+            #if 0
             AICWFDBG(LOGERROR, "usb rx refill fail\n");
             if (usb_dev->state != USB_UP_ST)
                 return;
+            #endif
         }
     }
+    usb_dev->rx_prepare_ready = true;
 }
 
 #ifdef CONFIG_USB_MSG_IN_EP
@@ -998,6 +1003,25 @@ int usb_bustx_thread(void *data)
 {
     struct aicwf_bus *bus = (struct aicwf_bus *)data;
     struct aic_usb_dev *usbdev = bus->bus_priv.usb;
+    int set_cpu_ret = 0;
+
+#ifdef CONFIG_THREAD_INFO_IN_TASK
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+	AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->thread_info.cpu);
+#else
+    AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->cpu);
+#endif
+#endif
+    set_cpu_ret = set_cpus_allowed_ptr(current, cpumask_of(1));
+#ifdef CONFIG_THREAD_INFO_IN_TASK
+    AICWFDBG(LOGINFO, "%s set_cpu_ret is:%d\n", __func__, set_cpu_ret);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+	AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->thread_info.cpu);
+#else
+    AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->cpu);
+#endif
+#endif
+
 
 #ifdef CONFIG_TXRX_THREAD_PRIO
 	if (bustx_thread_prio > 0) {
@@ -1046,6 +1070,24 @@ int usb_busrx_thread(void *data)
 {
     struct aicwf_rx_priv *rx_priv = (struct aicwf_rx_priv *)data;
     struct aicwf_bus *bus_if = rx_priv->usbdev->bus_if;
+    int set_cpu_ret = 0;
+    
+#ifdef CONFIG_THREAD_INFO_IN_TASK
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+	AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->thread_info.cpu);
+#else
+    AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->cpu);
+#endif
+#endif
+    set_cpu_ret = set_cpus_allowed_ptr(current, cpumask_of(1));
+#ifdef CONFIG_THREAD_INFO_IN_TASK
+    AICWFDBG(LOGINFO, "%s set_cpu_ret is:%d\n", __func__, set_cpu_ret);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0))
+	AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->thread_info.cpu);
+#else
+    AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->cpu);
+#endif
+#endif
 
 #ifdef CONFIG_TXRX_THREAD_PRIO
 	if (busrx_thread_prio > 0) {
@@ -1596,6 +1638,8 @@ static int aicwf_usb_bus_start(struct device *dev)
         return 0;
 
     aicwf_usb_state_change(usb_dev, USB_UP_ST);
+
+    usb_dev->rx_prepare_ready = false;
     aicwf_usb_rx_prepare(usb_dev);
     aicwf_usb_tx_prepare(usb_dev);
 #ifdef CONFIG_USB_MSG_IN_EP
@@ -1604,8 +1648,12 @@ static int aicwf_usb_bus_start(struct device *dev)
 		aicwf_usb_msg_rx_prepare(usb_dev);
 	}
 #endif
-
-    return 0;
+    if(!usb_dev->rx_prepare_ready){
+        AICWFDBG(LOGERROR, "%s rx prepare fail\r\n", __func__);
+        return -1;
+    }else{
+        return 0;
+    }
 }
 
 static void aicwf_usb_cancel_all_urbs_(struct aic_usb_dev *usb_dev)
@@ -1671,7 +1719,7 @@ static void aicwf_usb_bus_stop(struct device *dev)
     if (usb_dev->state == USB_DOWN_ST)
         return;
 
-    if(g_rwnx_plat->wait_disconnect_cb == true){
+    if(g_rwnx_plat && g_rwnx_plat->wait_disconnect_cb == true){
             atomic_set(&aicwf_deinit_atomic, 1);
             up(&aicwf_deinit_sem);
     }
@@ -2047,10 +2095,47 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
     #endif
 
     usb_dev = kzalloc(sizeof(struct aic_usb_dev), GFP_ATOMIC);
+    
+    AICWFDBG(LOGDEBUG, "%s usb_dev:%d usb_tx_buf:%d usb_rx_buf:%d\r\n", 
+        __func__, 
+        (int)sizeof(struct aic_usb_dev),
+        (int)sizeof(struct aicwf_usb_buf) * AICWF_USB_TX_URBS,
+        (int)sizeof(struct aicwf_usb_buf) * AICWF_USB_RX_URBS);
+
+
     if (!usb_dev) {
+        AICWFDBG(LOGERROR, "%s usb_dev kzalloc fail\r\n", __func__);
+        return -ENOMEM;
+    }
+
+    usb_dev->usb_tx_buf = vmalloc(sizeof(struct aicwf_usb_buf) * AICWF_USB_TX_URBS);
+    usb_dev->usb_rx_buf = vmalloc(sizeof(struct aicwf_usb_buf) * AICWF_USB_RX_URBS);
+
+    if(!usb_dev->usb_tx_buf || !usb_dev->usb_rx_buf){
+        if(usb_dev->usb_tx_buf){
+            vfree(usb_dev);
+        }
+        
+        if(usb_dev->usb_tx_buf){
+            vfree(usb_dev);
+        }
+        
+        if(usb_dev){
+            kfree(usb_dev);
+        }
+        AICWFDBG(LOGERROR, "%s usb_tx_buf or usb_rx_buf vmalloc fail\r\n", __func__);
         return -ENOMEM;
     }
 
+    memset(usb_dev->usb_tx_buf, 
+        0, 
+        (int)(sizeof(struct aicwf_usb_buf) * AICWF_USB_TX_URBS));
+    
+    memset(usb_dev->usb_rx_buf, 
+        0, 
+        (int)(sizeof(struct aicwf_usb_buf) * AICWF_USB_RX_URBS));
+
+
     usb_dev->udev = usb;
     usb_dev->dev = &usb->dev;
     usb_set_intfdata(intf, usb_dev);
@@ -2141,6 +2226,8 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
     aicwf_usb_deinit(usb_dev);
 out_free:
     usb_err("failed with errno %d\n", ret);
+    vfree(usb_dev->usb_tx_buf);
+    vfree(usb_dev->usb_rx_buf);
     kfree(usb_dev);
     usb_set_intfdata(intf, NULL);
     return ret;
@@ -2176,6 +2263,8 @@ static void aicwf_usb_disconnect(struct usb_interface *intf)
 #endif
 
     kfree(usb_dev->bus_if);
+    vfree(usb_dev->usb_tx_buf);
+    vfree(usb_dev->usb_rx_buf);
     kfree(usb_dev);
 	AICWFDBG(LOGINFO, "%s exit\r\n", __func__);
 	up(&aicwf_deinit_sem);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
index 37afc7fec8fb..a551c7512e4e 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
@@ -35,7 +35,7 @@ enum AICWF_IC{
 };
 
 
-#define AICWF_USB_RX_URBS               (200)//(200)
+#define AICWF_USB_RX_URBS               (20)//(200)
 #ifdef CONFIG_USB_MSG_IN_EP
 #define AICWF_USB_MSG_RX_URBS           (100)
 #endif
@@ -47,7 +47,7 @@ enum AICWF_IC{
 #endif
 #define AICWF_USB_TX_LOW_WATER         (AICWF_USB_TX_URBS/4)//25%
 #define AICWF_USB_TX_HIGH_WATER        (AICWF_USB_TX_LOW_WATER*3)//75%
-#define AICWF_USB_AGGR_MAX_PKT_SIZE     (2048*10)
+#define AICWF_USB_AGGR_MAX_PKT_SIZE     (2048*1)
 #define AICWF_USB_MAX_PKT_SIZE          (2048)
 #define AICWF_USB_FC_PERSTA_HIGH_WATER		64
 #define AICWF_USB_FC_PERSTA_LOW_WATER		16
@@ -132,9 +132,15 @@ struct aic_usb_dev {
 
     int tx_free_count;
     int tx_post_count;
-
+    bool rx_prepare_ready;
+#if 0
     struct aicwf_usb_buf usb_tx_buf[AICWF_USB_TX_URBS];
     struct aicwf_usb_buf usb_rx_buf[AICWF_USB_RX_URBS];
+#else
+    struct aicwf_usb_buf *usb_tx_buf;
+    struct aicwf_usb_buf *usb_rx_buf;
+#endif
+
 #ifdef CONFIG_USB_MSG_IN_EP
 	struct aicwf_usb_buf usb_msg_rx_buf[AICWF_USB_MSG_RX_URBS];
 #endif
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_wext_linux.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_wext_linux.c
index de591f69d384..fdfab4cfe7ed 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_wext_linux.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_wext_linux.c
@@ -400,7 +400,10 @@ static char *aicwf_get_iwe_stream_mac_addr(struct rwnx_hw* rwnx_hw,
 	iwe->cmd = SIOCGIWAP;
 	iwe->u.ap_addr.sa_family = ARPHRD_ETHER;
 
+	if(scan_re->bss && scan_re->bss->bssid){
 	memcpy(iwe->u.ap_addr.sa_data, scan_re->bss->bssid, ETH_ALEN);
+	}
+
 	start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_ADDR_LEN);
 	return start;
 }
@@ -878,19 +881,21 @@ static char *translate_scan(struct rwnx_hw* rwnx_hw,
 	struct iw_event iwe;
 	memset(&iwe, 0, sizeof(iwe));
 
-	
-	start = aicwf_get_iwe_stream_mac_addr(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_essid(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_protocol(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_chan(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_mode(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_encryption(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_rate(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_wpa_wpa2(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_wps(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_rssi(rwnx_hw, info, scan_re, start, stop, &iwe);
-
-	return start;
+	if(scan_re->bss){
+	    	start = aicwf_get_iwe_stream_mac_addr(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_essid(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_protocol(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_chan(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_mode(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_encryption(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_rate(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_wpa_wpa2(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_wps(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_rssi(rwnx_hw, info, scan_re, start, stop, &iwe);
+		return start;
+	} else{
+		return NULL;
+	}	
 }
 
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
index 635f86ea409c..2ca79521dd48 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
@@ -396,6 +396,9 @@ enum mm_msg_tag
 
     MM_CFG_RSSI_CFM,
 
+    MM_SET_VENDOR_SWCONFIG_REQ,
+    MM_SET_VENDOR_SWCONFIG_CFM,
+
     /// MAX number of messages
     MM_MAX,
 };
@@ -1932,6 +1935,7 @@ enum vendor_hwconfig_tag{
 	MAC_TIMESCALE_REQ,
 	CCA_THRESHOLD_REQ,
 	BWMODE_REQ,
+	CHIP_TEMP_GET_REQ,
 };
 
 enum {
@@ -1959,6 +1963,7 @@ struct mm_set_channel_access_req
 	u8_l  long_nav_en;
 	u8_l  cfe_en;
 	u8_l  rc_retry_cnt[3];
+	s8_l ccademod_th;
 };
 
 struct mm_set_mac_timescale_req
@@ -1989,6 +1994,25 @@ struct mm_set_bwmode_req
     u8_l bwmode;
 };
 
+struct mm_get_chip_temp_req
+{
+    u32_l hwconfig_id;
+};
+
+struct mm_get_chip_temp_cfm
+{
+    /// Temp degree val
+    s8_l degree;
+};
+
+struct mm_set_vendor_hwconfig_cfm
+{
+    u32_l hwconfig_id;
+    union {
+        struct mm_get_chip_temp_cfm chip_temp_cfm;
+    };
+};
+
 struct mm_set_txop_req
 {
 	u16_l txop_bk;
@@ -2012,6 +2036,71 @@ struct mm_get_fw_version_cfm
     u8_l fw_version[63];
 };
 
+struct mm_get_wifi_disable_cfm
+{
+    u8_l wifi_disable;
+};
+
+enum vendor_swconfig_tag
+{
+    BCN_CFG_REQ = 0,
+    TEMP_COMP_SET_REQ,
+    TEMP_COMP_GET_REQ,
+};
+
+struct mm_set_bcn_cfg_req
+{
+    /// Ignore or not bcn tim bcmc bit
+    bool_l tim_bcmc_ignored_enable;
+};
+
+struct mm_set_bcn_cfg_cfm
+{
+    /// Request status
+    bool_l tim_bcmc_ignored_status;
+};
+
+struct mm_set_temp_comp_req
+{
+    /// Enable or not temp comp
+    u8_l enable;
+    u8_l reserved[3];
+    u32_l tmr_period_ms;
+};
+
+struct mm_set_temp_comp_cfm
+{
+    /// Request status
+    u8_l status;
+};
+
+struct mm_get_temp_comp_cfm
+{
+    /// Request status
+    u8_l status;
+    /// Temp degree val
+    s8_l degree;
+};
+
+struct mm_set_vendor_swconfig_req
+{
+    u32_l swconfig_id;
+    union {
+        struct mm_set_bcn_cfg_req bcn_cfg_req;
+        struct mm_set_temp_comp_req temp_comp_set_req;
+    };
+};
+
+struct mm_set_vendor_swconfig_cfm
+{
+    u32_l swconfig_id;
+    union {
+        struct mm_set_bcn_cfg_cfm bcn_cfg_cfm;
+        struct mm_set_temp_comp_cfm temp_comp_set_cfm;
+        struct mm_get_temp_comp_cfm temp_comp_get_cfm;
+    };
+};
+
 /// Structure containing the parameters of the @ref ME_RC_STATS_REQ message.
 struct me_rc_stats_req
 {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
index 82346f8f5fb9..4cef4819df5f 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
@@ -491,12 +491,14 @@ void rwnx_cmd_mgr_init(struct rwnx_cmd_mgr *cmd_mgr)
 
 void rwnx_cmd_mgr_deinit(struct rwnx_cmd_mgr *cmd_mgr)
 {
-    cmd_mgr->print(cmd_mgr);
-    cmd_mgr->drain(cmd_mgr);
-    cmd_mgr->print(cmd_mgr);
-    flush_workqueue(cmd_mgr->cmd_wq);
-    destroy_workqueue(cmd_mgr->cmd_wq);
-    memset(cmd_mgr, 0, sizeof(*cmd_mgr));
+    if(cmd_mgr->print && cmd_mgr->drain){
+        cmd_mgr->print(cmd_mgr);
+        cmd_mgr->drain(cmd_mgr);
+        cmd_mgr->print(cmd_mgr);
+        flush_workqueue(cmd_mgr->cmd_wq);
+        destroy_workqueue(cmd_mgr->cmd_wq);
+        memset(cmd_mgr, 0, sizeof(*cmd_mgr));
+    }
 }
 
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
index de4974148796..fd5a92e7bfd1 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
@@ -491,7 +491,7 @@ static ssize_t rwnx_dbgfs_acsinfo_read(struct file *file,
 
     buf = (char*)kmalloc(sizeof(char) * ((SCAN_CHANNEL_MAX + 1) * 43), GFP_KERNEL);
     memset(buf, 0, ((SCAN_CHANNEL_MAX + 1) * 43));
-    
+
 	if (priv->band_5g_support){
 		band_max = NL80211_BAND_5GHZ + 1;
 	}
@@ -532,10 +532,10 @@ static ssize_t rwnx_dbgfs_acsinfo_read(struct file *file,
     mutex_unlock(&priv->dbgdump_elem.mutex);
 
     size = simple_read_from_buffer(user_buf, count, ppos, buf, len);
-    
+
     kfree(buf);
     buf = NULL;
-    
+
     return size;
 }
 
@@ -1255,7 +1255,7 @@ static ssize_t rwnx_dbgfs_regdbg_write(struct file *file,
 
     	buf[len] = '\0';
 
-	if (sscanf(buf, "%x %x %x" , &oper, &addr, &val ) > 0) 
+	if (sscanf(buf, "%x %x %x" , &oper, &addr, &val ) > 0)
 		printk("addr=%x, val=%x,oper=%d\n", addr, val, oper);
 
     	if(oper== 0) {
@@ -1274,7 +1274,8 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 {
 	struct rwnx_hw *priv = file->private_data;
 	char buf[64];
-	int32_t addr[12];
+	int32_t addr[13];
+    int32_t addr_out[12];
 	u32_l hwconfig_id;
 	size_t len = min_t(size_t,count,sizeof(buf)-1);
 	int ret;
@@ -1287,10 +1288,10 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 	}
 
 	buf[len] = '\0';
-	ret = sscanf(buf, "%x %x %x %x %x %x %x %x %x %x %x %x %x",
+	ret = sscanf(buf, "%x %x %x %x %x %x %x %x %x %x %x %x %x %x",
                             &hwconfig_id, &addr[0], &addr[1], &addr[2], &addr[3], &addr[4], &addr[5], &addr[6], &addr[7], &addr[8], &addr[9], &addr[10], &addr[11]);
-	if(ret > 13) {
-		printk("param error > 13\n");
+	if(ret > 14) {
+		printk("param error > 14\n");
 	} else {
 		switch(hwconfig_id)
 		    {
@@ -1298,22 +1299,22 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 			if(ret != 5) {
 			    printk("param error  != 5\n");
 			    break;}
-			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr);
+			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
 			printk("ACS_TXOP_REQ bk:0x%x be:0x%x vi:0x%x vo:0x%x\n",addr[0],  addr[1], addr[2], addr[3]);
 			break;
 		    case 1:
-			if(ret != 13) {
-			    printk("param error  != 13\n");
+			if(ret != 14) {
+			    printk("param error  != 14\n");
 			    break;}
-			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr);
-			printk("CHANNEL_ACCESS_REQ edca:%x,%x,%x,%x, vif:%x, retry_cnt:%x, rts:%x, long_nav:%x, cfe:%x, rc_retry_cnt:%x:%x:%x\n",
-                                addr[0],  addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], addr[8], addr[9], addr[10], addr[11]);
+			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
+			printk("CHANNEL_ACCESS_REQ edca:%x,%x,%x,%x, vif:%x, retry_cnt:%x, rts:%x, long_nav:%x, cfe:%x, rc_retry_cnt:%x:%x:%x ccademod_th %x\n",
+                                addr[0],  addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], addr[8], addr[9], addr[10], addr[11], addr[12]);
 			break;
 		    case 2:
 			if(ret != 7) {
 		            printk("param error  != 7\n");
 			    break;}
-			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr);
+			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
 			printk("MAC_TIMESCALE_REQ sifsA:%x,sifsB:%x,slot:%x,ofdm_delay:%x,long_delay:%x,short_delay:%x\n",
                                 addr[0],  addr[1], addr[2], addr[3], addr[4], addr[5]);
 			break;
@@ -1325,10 +1326,26 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 			addr[2] = ~addr[2] + 1;
 			addr[3] = ~addr[3] + 1;
 			addr[4] = ~addr[4] + 1;
-			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr);
+			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
 			printk("CCA_THRESHOLD_REQ auto_cca:%d, cca20p_rise:%d cca20s_rise:%d cca20p_fail:%d cca20s_fail:%d\n",
                                 addr[0],  addr[1], addr[2], addr[3], addr[4]);
 			break;
+            case 4: // BWMODE_REQ
+                if (ret != 2) {
+                    printk("param error != 2\n");
+                } else {
+                    ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
+                    printk("BWMODE_REQ md=%d\n", addr[0]);
+                }
+            break;
+            case 5: // CHIP_TEMP_GET_REQ
+                if (ret != 1) {
+                    printk("param error != 1\n");
+                } else {
+                    ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, addr_out);
+                    printk("CHIP_TEMP_GET_REQ degree=%d\n", addr_out[0]);
+                }
+            break;
 		    default:
 			printk("param error\n");
 			break;
@@ -1343,6 +1360,73 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 
 DEBUGFS_WRITE_FILE_OPS(vendor_hwconfig)
 
+static ssize_t rwnx_dbgfs_vendor_swconfig_write(struct file *file,
+            const char __user *user_buf,
+            size_t count, loff_t *ppos)
+{
+    struct rwnx_hw *priv = file->private_data;
+    char buf[64];
+    int32_t addr[12];
+    int32_t addr_out[12];
+    u32_l swconfig_id;
+    size_t len = min_t(size_t, count, sizeof(buf) - 1);
+    int ret;
+    printk("%s\n", __func__);
+
+    if (copy_from_user(buf, user_buf, len)) {
+        return -EFAULT;
+    }
+
+    buf[len] = '\0';
+    ret = sscanf(buf, "%x %x %x", &swconfig_id, &addr[0], &addr[1]);
+    if (ret > 3) {
+        printk("param error > 3\n");
+    } else {
+        switch (swconfig_id)
+        {
+            case 0: // BCN_CFG_REQ
+                if (ret != 2) {
+                    printk("param error != 2\n");
+                } else {
+                    ret = rwnx_send_vendor_swconfig_req(priv, swconfig_id, addr, addr_out);
+                    printk("BCN_CFG_REQ set_en=%d, get_en=%d\n", addr[0], addr_out[0]);
+                }
+            break;
+
+            case 1: // TEMP_COMP_SET_REQ
+                if (ret != 3) {
+                    printk("param error != 3\n");
+                } else {
+                    ret = rwnx_send_vendor_swconfig_req(priv, swconfig_id, addr, addr_out);
+                    printk("TEMP_COMP_SET_REQ set_en=%d, tmr=%dms, get_st=%d\n",
+                        addr[0], addr[1], addr_out[0]);
+                }
+            break;
+
+            case 2: // TEMP_COMP_GET_REQ
+                if (ret != 1) {
+                    printk("param error != 1\n");
+                } else {
+                    ret = rwnx_send_vendor_swconfig_req(priv, swconfig_id, addr, addr_out);
+                    printk("TEMP_COMP_GET_REQ get_st=%d, degree=%d\n", addr_out[0], addr_out[1]);
+                }
+            break;
+
+            default:
+                printk("param error\n");
+                break;
+        }
+
+        if (ret) {
+            printk("rwnx_send_vendor_swconfig_req fail: %x\n", ret);
+        }
+    }
+
+    return count;
+}
+
+DEBUGFS_WRITE_FILE_OPS(vendor_swconfig)
+
 extern int aicwf_dbg_level;
 static ssize_t rwnx_dbgfs_dbg_level_read(struct file *file,
 			char __user *user_buf,
@@ -2222,6 +2306,7 @@ int rwnx_dbgfs_register(struct rwnx_hw *rwnx_hw, const char *name)
 #endif
     DEBUGFS_ADD_FILE(regdbg, dir_drv, S_IWUSR);
 	DEBUGFS_ADD_FILE(vendor_hwconfig, dir_drv,S_IWUSR);
+	DEBUGFS_ADD_FILE(vendor_swconfig, dir_drv,S_IWUSR);
 	DEBUGFS_ADD_FILE(dbg_level, dir_drv, S_IWUSR | S_IRUSR);
 
 #ifdef CONFIG_RWNX_P2P_DEBUGFS
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
index fe94db72a8d1..c5f7dc2d20ea 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
@@ -30,6 +30,9 @@
 #include "rwnx_platform.h"
 #include "rwnx_cmds.h"
 #include "rwnx_compat.h"
+#ifdef CONFIG_FILTER_TCP_ACK
+#include "aicwf_tcp_ack.h"
+#endif
 
 #ifdef AICWF_SDIO_SUPPORT
 #include "aicwf_sdio.h"
@@ -57,6 +60,20 @@
 #define PS_SP_INTERRUPTED  255
 #define MAC_ADDR_LEN 6
 
+//because android kernel 5.15 uses kernel 6.0 or 6.1 kernel api
+#ifdef ANDROID_PLATFORM
+#define HIGH_KERNEL_VERSION KERNEL_VERSION(5, 15, 41)
+#define HIGH_KERNEL_VERSION2 KERNEL_VERSION(5, 15, 41)
+#define HIGH_KERNEL_VERSION3 KERNEL_VERSION(5, 15, 104)
+#define HIGH_KERNEL_VERSION4 KERNEL_VERSION(6, 1, 0)
+#else
+#define HIGH_KERNEL_VERSION KERNEL_VERSION(6, 0, 0)
+#define HIGH_KERNEL_VERSION2 KERNEL_VERSION(6, 1, 0)
+#define HIGH_KERNEL_VERSION3 KERNEL_VERSION(6, 3, 0)
+#define HIGH_KERNEL_VERSION4 KERNEL_VERSION(6, 3, 0)
+#endif
+
+
 
 #if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
 #define IEEE80211_MAX_AMPDU_BUF                             IEEE80211_MAX_AMPDU_BUF_HE
@@ -326,6 +343,7 @@ struct rwnx_vif {
     struct net_device *ndev;
     struct net_device_stats net_stats;
     struct rwnx_key key[6];
+    unsigned long drv_flags;
     atomic_t drv_conn_state;
     u8 drv_vif_index;           /* Identifier of the VIF in driver */
     u8 vif_index;               /* Identifier of the station in FW */
@@ -353,11 +371,13 @@ struct rwnx_vif {
             bool external_auth;  /* Indicate if external authentication is in progress */
             u32 group_cipher_type;
             u32 paired_cipher_type;
-            //connected network info start
-            char ssid[33];//ssid max is 32, but this has one spare for '\0'
-            int ssid_len;
-            u8 bssid[ETH_ALEN];
-            //connected network info end
+			//connected network info start
+			char ssid[33];//ssid max is 32, but this has one spare for '\0'
+			int ssid_len;
+			u8 bssid[ETH_ALEN];
+			u32 conn_owner_nlportid;
+			bool is_roam;
+			//connected network info end
         } sta;
         struct
         {
@@ -628,14 +648,16 @@ struct rwnx_hw {
     u8 cur_chanctx;
 
     u8 monitor_vif; /* FW id of the monitor interface, RWNX_INVALID_VIF if no monitor vif at fw level */
-
+#ifdef CONFIG_FILTER_TCP_ACK
+       /* tcp ack management */
+    struct tcp_ack_manage ack_m;
+#endif
     /* RoC Management */
     struct rwnx_roc_elem *roc_elem;             /* Information provided by cfg80211 in its remain on channel request */
     u32 roc_cookie_cnt;                         /* Counter used to identify RoC request sent by cfg80211 */
 
     struct rwnx_cmd_mgr *cmd_mgr;
 
-    unsigned long drv_flags;
     struct rwnx_plat *plat;
 
     spinlock_t tx_lock;
@@ -678,7 +700,7 @@ struct rwnx_hw {
 #endif
     struct rwnx_hwq hwq[NX_TXQ_CNT];
 
-    u8 avail_idx_map;
+    u64 avail_idx_map;
     u8 vif_started;
     bool adding_sta;
     struct rwnx_phy_info phy;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
index c9efdbca4c84..0e1d000a909c 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
@@ -182,13 +182,6 @@
     .max_power  = 30, /* FIXME */               \
 }
 
-#ifdef ANDROID_PLATFORM
-#define HIGH_KERNEL_VERSION KERNEL_VERSION(5, 15, 41)
-#else
-#define HIGH_KERNEL_VERSION KERNEL_VERSION(6, 5, 0)
-#endif
-
-
 static struct ieee80211_rate rwnx_ratetable[] = {
     RATE(10,  0x00, 0),
     RATE(20,  0x01, IEEE80211_RATE_SHORT_PREAMBLE),
@@ -1064,11 +1057,7 @@ static void rwnx_csa_finish(struct work_struct *ws)
         cfg80211_disconnected(vif->ndev, 0, NULL, 0, 0, GFP_KERNEL);
         #endif
     } else {
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
-	wiphy_lock(vif->wdev.wiphy);
-#else
         mutex_lock(&vif->wdev.mtx);
-#endif
         __acquire(&vif->wdev.mtx);
         spin_lock_bh(&rwnx_hw->cb_lock);
         rwnx_chanctx_unlink(vif);
@@ -1079,15 +1068,15 @@ static void rwnx_csa_finish(struct work_struct *ws)
         } else
             rwnx_txq_vif_stop(vif, RWNX_TXQ_STOP_CHAN, rwnx_hw);
         spin_unlock_bh(&rwnx_hw->cb_lock);
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
-                cfg80211_ch_switch_notify(vif->ndev, &csa->chandef, 0, 0);
-		wiphy_unlock(vif->wdev.wiphy);
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION3)
+		cfg80211_ch_switch_notify(vif->ndev, &csa->chandef, 0, 0);
+#elif (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+		cfg80211_ch_switch_notify(vif->ndev, &csa->chandef, 0);
 #else
-                cfg80211_ch_switch_notify(vif->ndev, &csa->chandef);
-                mutex_unlock(&vif->wdev.mtx);
-                __release(&vif->wdev.mtx);
+		cfg80211_ch_switch_notify(vif->ndev, &csa->chandef);
 #endif
-
+        mutex_unlock(&vif->wdev.mtx);
+        __release(&vif->wdev.mtx);
     }
     rwnx_del_csa(vif);
 }
@@ -1229,10 +1218,22 @@ static int rwnx_open(struct net_device *dev)
     struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
     struct mm_add_if_cfm add_if_cfm;
     int error = 0;
+    int err = 0;
     u8 rwnx_rx_gain = 0x0E;
+	int waiting_counter = 10;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
 
+	while(test_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags)){
+		msleep(100);
+		AICWFDBG(LOGDEBUG, "%s waiting for rwnx_close \r\n", __func__);
+		waiting_counter--;
+		if(waiting_counter == 0){
+			AICWFDBG(LOGERROR, "%s error waiting for close time out \r\n", __func__);
+			break;
+		}
+	}
+
     // Check if it is the first opened VIF
     if (rwnx_hw->vif_started == 0)
     {
@@ -1248,10 +1249,44 @@ static int rwnx_open(struct net_device *dev)
        }
 
        /* Device is now started */
-       set_bit(RWNX_DEV_STARTED, &rwnx_hw->drv_flags);
+       set_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags);
 	   atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
     }
 
+	if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO)
+    {
+        #ifdef CONFIG_COEX
+        rwnx_send_coex_req(rwnx_hw, 1, 0);
+        #endif
+    }
+
+	if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO) {
+		if (!rwnx_hw->is_p2p_alive) {
+			if (rwnx_hw->p2p_dev_vif && !rwnx_hw->p2p_dev_vif->up) {
+				err = rwnx_send_add_if (rwnx_hw, rwnx_hw->p2p_dev_vif->wdev.address,
+											  RWNX_VIF_TYPE(rwnx_hw->p2p_dev_vif), false, &add_if_cfm);
+				if (err) {
+					return -EIO;
+				}
+
+				if (add_if_cfm.status != 0) {
+					return -EIO;
+				}
+
+				/* Save the index retrieved from LMAC */
+				spin_lock_bh(&rwnx_hw->cb_lock);
+				rwnx_hw->p2p_dev_vif->vif_index = add_if_cfm.inst_nbr;
+				rwnx_hw->p2p_dev_vif->up = true;
+				rwnx_hw->vif_started++;
+				rwnx_hw->vif_table[add_if_cfm.inst_nbr] = rwnx_hw->p2p_dev_vif;
+				spin_unlock_bh(&rwnx_hw->cb_lock);
+			}
+			rwnx_hw->is_p2p_alive = 1;
+			mod_timer(&rwnx_hw->p2p_alive_timer, jiffies + msecs_to_jiffies(1000));
+			atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
+		}
+	}
+
     if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP_VLAN) {
         /* For AP_vlan use same fw and drv indexes. We ensure that this index
            will not be used by fw for another vif by taking index >= NX_VIRT_DEV_MAX */
@@ -1300,13 +1335,6 @@ static int rwnx_open(struct net_device *dev)
 
     }
 
-    if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO)
-    {
-        #ifdef CONFIG_COEX
-        rwnx_send_coex_req(rwnx_hw, 1, 0);
-        #endif
-    }
-
     if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_MONITOR){
         rwnx_hw->monitor_vif = rwnx_vif->vif_index;
         if (rwnx_vif->ch_index != RWNX_CH_NOT_SET){
@@ -1350,7 +1378,9 @@ static int rwnx_close(struct net_device *dev)
     struct rwnx_vif *rwnx_vif = netdev_priv(dev);
     struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
     struct aicwf_bus *bus_if = NULL;
-	int ret = 0;
+    int ret = 0;
+    int waiting_counter = 20;
+    int test_counter = 0;
 #if defined(AICWF_USB_SUPPORT)
     struct aic_usb_dev *usbdev = NULL;
     bus_if = dev_get_drvdata(rwnx_hw->dev);
@@ -1366,6 +1396,19 @@ static int rwnx_close(struct net_device *dev)
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
 
+	test_counter = waiting_counter;
+	while(atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING||
+		atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTING){
+		AICWFDBG(LOGDEBUG, "%s wifi is connecting or disconnecting, waiting 200ms for state to stable\r\n", __func__);
+		msleep(200);
+		test_counter--;
+		if(test_counter == 0){
+			AICWFDBG(LOGERROR, "%s connecting or disconnecting, not finish\r\n", __func__);
+			WARN_ON(1);
+			break;
+		}
+	}
+
 #if defined(AICWF_USB_SUPPORT) || defined(AICWF_SDIO_SUPPORT)
     if (scanning){
         scanning = false;
@@ -1417,9 +1460,17 @@ static int rwnx_close(struct net_device *dev)
 
 		if(RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION ||
 			RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT){
-			if(atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTING){
+			test_counter = waiting_counter;
+			if(atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTED){
+				atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
 				rwnx_send_sm_disconnect_req(rwnx_hw, rwnx_vif, 3);
-				atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
+				while (atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING) {
+					AICWFDBG(LOGDEBUG, "%s wifi is disconnecting, waiting 100ms for state to stable\r\n", __func__);
+					msleep(100);
+					test_counter--;
+					if (test_counter ==0)
+						break;
+				}
 			}
 		}
 #ifdef CONFIG_USE_P2P0
@@ -1515,7 +1566,7 @@ static int rwnx_close(struct net_device *dev)
             #endif
         }
         #endif
-        clear_bit(RWNX_DEV_STARTED, &rwnx_hw->drv_flags);
+        clear_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags);
     }
 
     return 0;
@@ -2977,7 +3028,6 @@ static struct rwnx_vif *rwnx_interface_add(struct rwnx_hw *rwnx_hw,
     int i;
     int nx_nb_ndev_txq = NX_NB_NDEV_TXQ;
 
-
     if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
 		((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
 		g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
@@ -3101,16 +3151,24 @@ static struct rwnx_vif *rwnx_interface_add(struct rwnx_hw *rwnx_hw,
         break;
     }
 
-    if (type == NL80211_IFTYPE_AP_VLAN) {
-        memcpy(ndev->dev_addr, params->macaddr, ETH_ALEN);
-        memcpy(vif->wdev.address, params->macaddr, ETH_ALEN);
-    }
-    else {
-        memcpy(ndev->dev_addr, rwnx_hw->wiphy->perm_addr, ETH_ALEN);
-        //ndev->dev_addr[5] ^= vif_idx;
-	vif->wdev.address[5] ^= vif_idx;
-        memcpy(vif->wdev.address, ndev->dev_addr, ETH_ALEN);
-    }
+	if (type == NL80211_IFTYPE_AP_VLAN) {
+		memcpy((void *)ndev->dev_addr, (const void *)params->macaddr, ETH_ALEN);
+		memcpy((void *)vif->wdev.address, (const void *)params->macaddr, ETH_ALEN);
+	} else {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 17, 0)
+		unsigned char mac_addr[6];
+		memcpy(mac_addr, rwnx_hw->wiphy->perm_addr, ETH_ALEN);
+		mac_addr[5] ^= vif_idx;
+		//memcpy(ndev->dev_addr, mac_addr, ETH_ALEN);
+		eth_hw_addr_set(ndev, mac_addr);
+		memcpy(vif->wdev.address, mac_addr, ETH_ALEN);
+#else
+		memcpy(ndev->dev_addr, rwnx_hw->wiphy->perm_addr, ETH_ALEN);
+		ndev->dev_addr[5] ^= vif_idx;
+		memcpy(vif->wdev.address, ndev->dev_addr, ETH_ALEN);
+#endif
+	}
+
 
 	AICWFDBG(LOGINFO, "interface add:%x %x %x %x %x %x\n", vif->wdev.address[0], vif->wdev.address[1],
         vif->wdev.address[2], vif->wdev.address[3], vif->wdev.address[4], vif->wdev.address[5]);
@@ -3470,7 +3528,7 @@ static int rwnx_cfg80211_change_iface(struct wiphy *wiphy,
     int ret;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
-	AICWFDBG(LOGINFO, "change_if: %d to %d, %d, %d", vif->wdev.iftype, type, NL80211_IFTYPE_P2P_CLIENT, NL80211_IFTYPE_STATION);
+	AICWFDBG(LOGINFO, "change_if: %d to %d, %d, %d\r\n", vif->wdev.iftype, type, NL80211_IFTYPE_P2P_CLIENT, NL80211_IFTYPE_STATION);
 
 #ifdef CONFIG_COEX
     if (type == NL80211_IFTYPE_AP || type == NL80211_IFTYPE_P2P_GO)
@@ -3536,6 +3594,7 @@ static int rwnx_cfg80211_change_iface(struct wiphy *wiphy,
 	    /* Abort scan request on the vif */
 	    if (vif->rwnx_hw->scan_request &&
 	        vif->rwnx_hw->scan_request->wdev == &vif->wdev) {
+#if 0
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
 	        struct cfg80211_scan_info info = {
 	            .aborted = true,
@@ -3549,7 +3608,14 @@ static int rwnx_cfg80211_change_iface(struct wiphy *wiphy,
 	            return ret;
 	        }
 	        vif->rwnx_hw->scan_request = NULL;
+#else
+            if ((ret = rwnx_send_scanu_cancel_req(vif->rwnx_hw, NULL))) {
+                AICWFDBG(LOGERROR, "scanu_cancel fail\n");
+                return ret;
+            }
+#endif
 	    }
+        
 	    if ((ret = rwnx_send_remove_if(vif->rwnx_hw, vif->vif_index, false))) {
 			AICWFDBG(LOGERROR, "remove_if fail\n");
 	        return ret;
@@ -3756,7 +3822,7 @@ bool key_flag = false;
  *	when adding a group key.
  */
 static int rwnx_cfg80211_add_key(struct wiphy *wiphy, struct net_device *netdev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                                                  int link_id,
 #endif
                                  u8 key_index, bool pairwise, const u8 *mac_addr,
@@ -3852,7 +3918,7 @@ static int rwnx_cfg80211_add_key(struct wiphy *wiphy, struct net_device *netdev,
  *
  */
 static int rwnx_cfg80211_get_key(struct wiphy *wiphy, struct net_device *netdev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                                                  int link_id,
 #endif
 
@@ -3871,7 +3937,7 @@ static int rwnx_cfg80211_get_key(struct wiphy *wiphy, struct net_device *netdev,
  *	and @key_index, return -ENOENT if the key doesn't exist.
  */
 static int rwnx_cfg80211_del_key(struct wiphy *wiphy, struct net_device *netdev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                                                  int link_id,
 #endif
 
@@ -3912,7 +3978,7 @@ static int rwnx_cfg80211_del_key(struct wiphy *wiphy, struct net_device *netdev,
  */
 static int rwnx_cfg80211_set_default_key(struct wiphy *wiphy,
                                          struct net_device *netdev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                                                  int link_id,
 #endif
                                          u8 key_index, bool unicast, bool multicast)
@@ -3927,7 +3993,7 @@ static int rwnx_cfg80211_set_default_key(struct wiphy *wiphy,
  */
 static int rwnx_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,
                                               struct net_device *netdev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                                                  int link_id,
 #endif
                                               u8 key_index)
@@ -3964,8 +4030,16 @@ static int rwnx_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 		return -EALREADY;
 	}
 #endif
-	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING){
-		AICWFDBG(LOGERROR, "%s driver is disconnecting return it \r\n", __func__);
+	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTED) {
+		AICWFDBG(LOGDEBUG, "%s this connection is roam \r\n", __func__);
+		rwnx_vif->sta.is_roam = true;
+	}else{
+		rwnx_vif->sta.is_roam = false; 
+	}
+
+	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING||
+		(int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTING) {
+		AICWFDBG(LOGERROR, "%s driver is disconnecting or connecting ,return it \r\n", __func__);
 		return -EALREADY;
 	}
 #endif
@@ -4009,7 +4083,7 @@ static int rwnx_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
         key_params.seq_len = 0;
         key_params.cipher = sme->crypto.cipher_group;
         rwnx_cfg80211_add_key(wiphy, dev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                 0,
 #endif
 	sme->key_idx, false, NULL, &key_params);
@@ -4093,6 +4167,12 @@ static int rwnx_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 		msleep(500);
 	}
 
+	if(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_DISCONNECTING) {
+		AICWFDBG(LOGERROR, "%s wifi is disconnecting, return it:%d \r\n",
+				__func__, reason_code);
+		return -EBUSY;
+	}
+
 	if(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTED){
 		atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
 
@@ -4105,6 +4185,7 @@ static int rwnx_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 		cfg80211_connect_result(dev,  NULL, NULL, 0, NULL, 0,
 			reason_code?reason_code:WLAN_STATUS_UNSPECIFIED_FAILURE, GFP_ATOMIC);
 		atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
+		rwnx_external_auth_disable(rwnx_vif);
 		return 0;
 	}
 
@@ -4916,18 +4997,9 @@ static int rwnx_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *dev,
  * @change_beacon: Change the beacon parameters for an access point mode
  *	interface. This should reject the call when AP mode wasn't started.
  */
-// for mainline linux 
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
-static int rwnx_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *dev,
-                                       struct cfg80211_ap_update *params)
-#else
 static int rwnx_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *dev,
                                        struct cfg80211_beacon_data *info)
-#endif
 {
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
-    struct cfg80211_beacon_data *info = &params->beacon;
-#endif
     struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
     struct rwnx_vif *vif = netdev_priv(dev);
     struct rwnx_bcn *bcn = &vif->ap.bcn;
@@ -5435,6 +5507,10 @@ static int rwnx_cfg80211_cancel_remain_on_channel(struct wiphy *wiphy,
     return rwnx_send_cancel_roc(rwnx_hw);
 }
 
+#define IS_2P4GHZ(n) (n >= 2412 && n <= 2484)
+#define IS_5GHZ(n) (n >= 4000 && n <= 5895)
+#define DEFAULT_NOISE_FLOOR_2GHZ (-89)
+#define DEFAULT_NOISE_FLOOR_5GHZ (-92)
 /**
  * @dump_survey: get site survey information.
  */
@@ -5482,7 +5558,10 @@ static int rwnx_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *net
     if (rwnx_survey->filled != 0) {
         SURVEY_TIME(info) = (u64)rwnx_survey->chan_time_ms;
         SURVEY_TIME_BUSY(info) = (u64)rwnx_survey->chan_time_busy_ms;
-        info->noise = rwnx_survey->noise_dbm;
+        //info->noise = rwnx_survey->noise_dbm;
+	info->noise = ((IS_2P4GHZ(info->channel->center_freq)) ? DEFAULT_NOISE_FLOOR_2GHZ :
+			(IS_5GHZ(info->channel->center_freq)) ? DEFAULT_NOISE_FLOOR_5GHZ : DEFAULT_NOISE_FLOOR_5GHZ);
+
 
         // Set the survey report as not used
         if(info->noise == 0){
@@ -5503,11 +5582,11 @@ static int rwnx_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *net
  */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
 static int rwnx_cfg80211_get_channel(struct wiphy *wiphy,
-                                                                         struct wireless_dev *wdev,
+                                                    struct wireless_dev *wdev,
 #if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
-                                                                         unsigned int link_id,
+                                                    unsigned int link_id,
 #endif
-                                                                         struct cfg80211_chan_def *chandef)
+                                                    struct cfg80211_chan_def *chandef)
 {
     struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
     struct rwnx_vif *rwnx_vif = container_of(wdev, struct rwnx_vif, wdev);
@@ -5854,9 +5933,10 @@ int rwnx_cfg80211_channel_switch(struct wiphy *wiphy,
         goto end;
     } else {
         INIT_WORK(&csa->work, rwnx_csa_finish);
-
-#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
-        cfg80211_ch_switch_started_notify(dev, &csa->chandef, 0, params->count, false, 0);
+#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION4
+		cfg80211_ch_switch_started_notify(dev, &csa->chandef, 0, params->count, false, 0);
+#elif LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2
+        cfg80211_ch_switch_started_notify(dev, &csa->chandef, 0, params->count, false);
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
         cfg80211_ch_switch_started_notify(dev, &csa->chandef, params->count, params->block_tx);
 #else
@@ -6860,7 +6940,7 @@ static struct cfg80211_ops rwnx_cfg80211_ops = {
     .start_radar_detection = rwnx_cfg80211_start_radar_detection,
     .update_ft_ies = rwnx_cfg80211_update_ft_ies,
     .set_cqm_rssi_config = rwnx_cfg80211_set_cqm_rssi_config,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
     .channel_switch = rwnx_cfg80211_channel_switch,
 #endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
@@ -9131,6 +9211,9 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
     struct aic_feature_t feature;
 #endif
     struct mm_set_stack_start_cfm set_start_cfm;
+#ifdef CONFIG_TEMP_COMP
+	struct mm_set_vendor_swconfig_cfm swconfig_cfm;
+#endif
 
     int nx_remote_sta_max = NX_REMOTE_STA_MAX;
 
@@ -9192,6 +9275,12 @@ if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
         goto err_cache;
     }
 
+
+#ifdef CONFIG_FILTER_TCP_ACK
+     AICWFDBG(LOGINFO, "%s: FILTER_TCP_ACK\n", __func__);
+    tcp_ack_init(rwnx_hw);
+#endif
+
 #if 0
     if ((ret = rwnx_parse_configfile(rwnx_hw, RWNX_CONFIG_FW_NAME, &init_conf))) {
         wiphy_err(wiphy, "rwnx_parse_configfile failed\n");
@@ -9394,6 +9483,10 @@ if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
     if ((ret = rwnx_send_reset(rwnx_hw)))
         goto err_lmac_reqs;
 
+#ifdef CONFIG_TEMP_COMP
+	rwnx_send_set_temp_comp_req(rwnx_hw, &swconfig_cfm);
+#endif
+
     if ((ret = rwnx_send_version_req(rwnx_hw, &rwnx_hw->version_cfm)))
         goto err_lmac_reqs;
     rwnx_set_vers(rwnx_hw);
@@ -9556,6 +9649,9 @@ void rwnx_cfg80211_deinit(struct rwnx_hw *rwnx_hw)
     rwnx_radar_detection_deinit(&rwnx_hw->radar);
     rwnx_platform_off(rwnx_hw, NULL);
     kmem_cache_destroy(rwnx_hw->sw_txhdr_cache);
+#ifdef CONFIG_FILTER_TCP_ACK
+    tcp_ack_deinit(rwnx_hw);
+#endif
 	if(rwnx_hw->wiphy){
     	wiphy_free(rwnx_hw->wiphy);
 	}
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
index 5e160c13b5bc..146bba6a2dea 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
@@ -1193,6 +1193,11 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
                         IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G;
         he_cap->ppe_thres[0] |= 0x10;
     }
+    if (rwnx_hw->mod_params->use_80) {
+        he_cap->ppe_thres[0] |= 0x20;
+        he_cap->ppe_thres[2] |= 0xc0;
+        he_cap->ppe_thres[3] |= 0x07;
+    }
     //if (rwnx_hw->mod_params->use_80)
     {
         he_cap->he_cap_elem.phy_cap_info[0] |=
@@ -1318,6 +1323,11 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
                         IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G;
         he_cap->ppe_thres[0] |= 0x10;
     }
+    if (rwnx_hw->mod_params->use_80) {
+        he_cap->ppe_thres[0] |= 0x20;
+        he_cap->ppe_thres[2] |= 0xc0;
+        he_cap->ppe_thres[3] |= 0x07;
+    }
     //if (rwnx_hw->mod_params->use_80)
     {
         he_cap->he_cap_elem.phy_cap_info[0] |=
@@ -1424,6 +1434,11 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	                        IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G;
 	        he_cap->ppe_thres[0] |= 0x10;
 	    }
+	    if (rwnx_hw->mod_params->use_80) {
+		he_cap->ppe_thres[0] |= 0x20;
+		he_cap->ppe_thres[2] |= 0xc0;
+		he_cap->ppe_thres[3] |= 0x07;
+	    }
 	    //if (rwnx_hw->mod_params->use_80)
 	    {
 	        he_cap->he_cap_elem.phy_cap_info[0] |=
@@ -1729,11 +1744,7 @@ void rwnx_custregd(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 // registration (in rwnx_set_wiphy_params()), so nothing has to be done here
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
-    // nop
-#else
     wiphy->regulatory_flags |= REGULATORY_IGNORE_STALE_KICKOFF;
-#endif
     wiphy->regulatory_flags |= REGULATORY_WIPHY_SELF_MANAGED;
 
     if (!rwnx_hw->mod_params->custregd)
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
index 909e3f0f3270..0bd3e4932c59 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
@@ -28,6 +28,7 @@
 #ifdef CONFIG_USE_WIRELESS_EXT
 #include "aicwf_wext_linux.h"
 #endif
+void rwnx_cfg80211_unlink_bss(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif);
 
 static int rwnx_freq_to_idx(struct rwnx_hw *rwnx_hw, int freq)
 {
@@ -712,7 +713,7 @@ static inline int rwnx_rx_scanu_result_ind(struct rwnx_hw *rwnx_hw,
                                         ind->length, ind->rssi * 100, GFP_ATOMIC);
 #if 0
         //print scan result info start
-        if(ie != NULL){
+        if(ie != NULL && bss != NULL){
             ssid_len = ie[1];
             ssid = (char *)vmalloc(sizeof(char)* (ssid_len + 1));
             if(ssid != NULL){
@@ -848,15 +849,18 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
     const u8 *extcap_ie;
     const struct ieee_types_extcap *extcap;
     struct ieee80211_channel *chan;
+	struct cfg80211_bss *bss = NULL;
+    struct wireless_dev *wdev = NULL;
+    int retry_counter = 10;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
-
+	
 	if(!rwnx_vif){
 		AICWFDBG(LOGERROR, "%s rwnx_vif is null \r\n", __func__);
 		return 0;
 	}
 	dev = rwnx_vif->ndev;
-
+    wdev = dev->ieee80211_ptr;
 
     /* Retrieve IE addresses and lengths */
     req_ie = (const u8 *)ind->assoc_ie_buf;
@@ -964,7 +968,7 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
             rwnx_chanctx_link(rwnx_mon_vif, ind->ch_idx, NULL);
         }
 #endif
-		atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+		//atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
 
     } else if (ind->status_code == WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG) {
         if (rwnx_vif->wep_enabled) {
@@ -983,39 +987,115 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
         ind->status_code,
         (int)atomic_read(&rwnx_vif->drv_conn_state));
 
+	do {
+		bss = cfg80211_get_bss(wdev->wiphy, NULL, rwnx_vif->sta.bssid,
+#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
+							wdev->u.client.ssid, wdev->u.client.ssid_len,
+#else
+							wdev->ssid, wdev->ssid_len,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+							wdev->conn_bss_type,
+							IEEE80211_PRIVACY_ANY);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+							IEEE80211_BSS_TYPE_ESS,
+							IEEE80211_PRIVACY_ANY);
+#else
+                            WLAN_CAPABILITY_ESS,
+                            WLAN_CAPABILITY_PRIVACY);
+#endif
+
+
+		if (!bss) {
+			printk("%s bss is NULL \r\n", __func__);
+
+			printk("%s bss ssid(%d):%s conn_bss_type:%d bss2 ssid(%d):%s conn_bss_type:%d\r\n", 
+				__func__, 
+				(int)rwnx_vif->sta.ssid_len,
+				rwnx_vif->sta.ssid,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+				IEEE80211_BSS_TYPE_ESS,
+#else
+				WLAN_CAPABILITY_ESS,
+#endif
+#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
+				(int)wdev->u.client.ssid_len,
+				wdev->u.client.ssid, 
+#else
+				(int)wdev->ssid_len,
+				wdev->ssid,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+				wdev->conn_bss_type
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+				IEEE80211_BSS_TYPE_ESS
+#else
+				WLAN_CAPABILITY_ESS
+#endif
+				);
+
+			printk("%s rwnx_vif->sta.bssid %02x %02x %02x %02x %02x %02x \r\n", __func__, 
+				rwnx_vif->sta.bssid[0], rwnx_vif->sta.bssid[1], rwnx_vif->sta.bssid[2],
+				rwnx_vif->sta.bssid[3], rwnx_vif->sta.bssid[4], rwnx_vif->sta.bssid[5]);
+
+#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
+			wdev->u.client.ssid_len = (int)rwnx_vif->sta.ssid_len;
+			memcpy(wdev->u.client.ssid, rwnx_vif->sta.ssid, wdev->u.client.ssid_len);
+#else
+			wdev->ssid_len = (int)rwnx_vif->sta.ssid_len;
+			memcpy(wdev->ssid, rwnx_vif->sta.ssid, wdev->ssid_len);
+#endif
+			msleep(100);
+			retry_counter--;
+			if(retry_counter == 0){
+				printk("%s bss recover fail \r\n", __func__);
+				break;
+			}
+		}
+	} while (!bss);
 
     if (!ind->roamed) {//not roaming
         cfg80211_connect_result(dev, (const u8 *)ind->bssid.array, req_ie,
                                 ind->assoc_req_ie_len, rsp_ie,
                                 ind->assoc_rsp_ie_len, ind->status_code,
                                 GFP_ATOMIC);
+		if (ind->status_code == 0) {
+			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+		} else {
+			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+			rwnx_external_auth_disable(rwnx_vif);
+		}
+		AICWFDBG(LOGINFO, "%s cfg80211_connect_result pass, rwnx_vif->drv_conn_state:%d\r\n", __func__, (int)atomic_read(&rwnx_vif->drv_conn_state));
     }
     else {//roaming
         if(ind->status_code != 0){
             AICWFDBG(LOGINFO, "%s roaming fail to notify disconnect \r\n", __func__);
 			cfg80211_disconnected(dev, 0, NULL, 0,1, GFP_ATOMIC);
+			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+			rwnx_external_auth_disable(rwnx_vif);
         }else{
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
             struct cfg80211_roam_info info;
             memset(&info, 0, sizeof(info));
-            if (rwnx_vif->ch_index < NX_CHAN_CTXT_CNT)
+            
 #if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
+			if (rwnx_vif->ch_index < NX_CHAN_CTXT_CNT)
     			info.channel = rwnx_hw->chanctx_table[rwnx_vif->ch_index].chan_def.chan;
+			info.bssid = (const u8 *)ind->bssid.array;
+
 #else
+			if (rwnx_vif->ch_index < NX_CHAN_CTXT_CNT)
     			info.links[0].channel = rwnx_hw->chanctx_table[rwnx_vif->ch_index].chan_def.chan;
+			info.links[0].bssid = (const u8 *)ind->bssid.array;;
 #endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION    
 
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-            info.bssid = (const u8 *)ind->bssid.array;
-#else
-            info.links[0].bssid = (const u8 *)ind->bssid.array;;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
             info.req_ie = req_ie;
             info.req_ie_len = ind->assoc_req_ie_len;
             info.resp_ie = rsp_ie;
             info.resp_ie_len = ind->assoc_rsp_ie_len;
             AICWFDBG(LOGINFO, "%s roaming success to notify roam \r\n", __func__);
             cfg80211_roamed(dev, &info, GFP_ATOMIC);
+			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
 #else
             chan = ieee80211_get_channel(rwnx_hw->wiphy, ind->center_freq);
             AICWFDBG(LOGINFO, "%s roaming success to notify roam \r\n", __func__);
@@ -1030,7 +1110,8 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
                 , ind->assoc_rsp_ie_len
                 , GFP_ATOMIC);
 #endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)*/
-            }
+			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+		}
     }
     netif_tx_start_all_queues(dev);
     netif_carrier_on(dev);
@@ -1038,7 +1119,6 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
     return 0;
 }
 
-#if 0//maybe problem exist comment it AIDEN
 void rwnx_cfg80211_unlink_bss(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif){
 	struct wiphy *wiphy = rwnx_hw->wiphy;
 	struct cfg80211_bss *bss = NULL;
@@ -1065,14 +1145,9 @@ void rwnx_cfg80211_unlink_bss(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif
 		cfg80211_put_bss(bss);
 #endif
 	}else{
-		AICWFDBG(LOGERROR, "%s(): cfg80211_unlink error %s!!\n", __func__, rwnx_vif->sta.ssid);
+		AICWFDBG(LOGINFO, "%s(): cfg80211_unlink error %s!!\n", __func__, rwnx_vif->sta.ssid);
 	}
-
-	memset(rwnx_vif->sta.ssid, 0, rwnx_vif->sta.ssid_len);
-	rwnx_vif->sta.ssid_len = 0;
-	memset(rwnx_vif->sta.bssid, 0, ETH_ALEN);
 }
-#endif//maybe problem exist comment it AIDEN
 
 extern u8 dhcped;
 static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
@@ -1089,6 +1164,11 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
 #endif
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
+	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTED){
+		AICWFDBG(LOGINFO, "%s, is already disconnected, drop disconnect ind", __func__);
+		return 0;
+	}
+
     dhcped = 0;
 
     if(!rwnx_vif){
@@ -1097,9 +1177,11 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
         return 0;
     }
     dev = rwnx_vif->ndev;
-#if 0//maybe problem exist comment it AIDEN
-	rwnx_cfg80211_unlink_bss(rwnx_hw, rwnx_vif);
-#endif
+	if (rwnx_vif->sta.is_roam == false) {
+		rwnx_cfg80211_unlink_bss(rwnx_hw, rwnx_vif);
+	} else {
+		AICWFDBG(LOGINFO, "%s roaming no rwnx_cfg80211_unlink_bss \r\n", __func__);
+	}
 
 #ifdef CONFIG_BR_SUPPORT
 	struct rwnx_vif *vif = netdev_priv(dev);
@@ -1131,11 +1213,11 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
     rx_priv = rwnx_hw->usbdev->rx_priv;
 #endif
     if((rwnx_vif->wdev.iftype == NL80211_IFTYPE_STATION) || (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)) {
-        macaddr = rwnx_vif->ndev->dev_addr;
+        macaddr = (u8*)rwnx_vif->ndev->dev_addr;
 		AICWFDBG(LOGINFO, "deinit:macaddr:%x,%x,%x,%x,%x,%x\r\n", macaddr[0],macaddr[1],macaddr[2], \
                                macaddr[3],macaddr[4],macaddr[5]);
         list_for_each_entry_safe(reord_info, tmp, &rx_priv->stas_reord_list, list) {
-            macaddr = rwnx_vif->ndev->dev_addr;
+            macaddr = (u8*)rwnx_vif->ndev->dev_addr;
 			AICWFDBG(LOGINFO, "reord_mac:%x,%x,%x,%x,%x,%x\r\n", reord_info->mac_addr[0],reord_info->mac_addr[1],reord_info->mac_addr[2], \
                                    reord_info->mac_addr[3],reord_info->mac_addr[4],reord_info->mac_addr[5]);
             if (!memcmp(reord_info->mac_addr, macaddr, 6)) {
@@ -1173,6 +1255,9 @@ static inline int rwnx_rx_sm_external_auth_required_ind(struct rwnx_hw *rwnx_hw,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0) || defined(CONFIG_WPA3_FOR_OLD_KERNEL)
     struct net_device *dev = rwnx_vif->ndev;
     struct cfg80211_external_auth_params params;
+	int ret = 0;
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	int retry_counter = 10;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
 
@@ -1183,11 +1268,28 @@ static inline int rwnx_rx_sm_external_auth_required_ind(struct rwnx_hw *rwnx_hw,
            min_t(size_t, ind->ssid.length, sizeof(params.ssid.ssid)));
     params.key_mgmt_suite = ind->akm;
 
+	while (wdev->conn_owner_nlportid == 0) {
+		AICWFDBG(LOGINFO, "%s WARNING conn_owner_nlportid = 0, msleep 100ms.\r\n", __func__);
+		msleep(100);
+		retry_counter--;
+		if (retry_counter == 0) {
+			break;
+		}
+	}
+	AICWFDBG(LOGINFO, "%s wdev->conn_owner_nlportid:%d \r\n", __func__, (int)wdev->conn_owner_nlportid);
+
+	if (wdev->conn_owner_nlportid != 0) {
+		rwnx_vif->sta.conn_owner_nlportid = wdev->conn_owner_nlportid;
+	} else {
+		AICWFDBG(LOGINFO, "%s try to recover conn_owner_nlportid\r\n", __func__);
+		wdev->conn_owner_nlportid = rwnx_vif->sta.conn_owner_nlportid;
+	}
+
     if ((ind->vif_idx > NX_VIRT_DEV_MAX) || !rwnx_vif->up ||
         (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_STATION) ||
-        cfg80211_external_auth_request(dev, &params, GFP_ATOMIC)) {
-        wiphy_err(rwnx_hw->wiphy, "Failed to start external auth on vif %d",
-                  ind->vif_idx);
+        (ret = cfg80211_external_auth_request(dev, &params, GFP_ATOMIC))) {
+		wiphy_err(rwnx_hw->wiphy, "Failed to start external auth on vif %d, rwnx_vif->up %d, iftype:%d, ret %d",
+				  ind->vif_idx, rwnx_vif->up, RWNX_VIF_TYPE(rwnx_vif), ret);
         rwnx_send_sm_external_auth_required_rsp(rwnx_hw, rwnx_vif,
                                                 WLAN_STATUS_UNSPECIFIED_FAILURE);
         return 0;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
index 9983c68e9892..389a60629738 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
@@ -1266,60 +1266,33 @@ int rwnx_send_set_stack_start_req(struct rwnx_hw *rwnx_hw, u8_l on, u8_l efuse_v
     return error;
 }
 
-#if 0
-int rwnx_send_txop_req(struct rwnx_hw *rwnx_hw, uint16_t *txop, u8_l long_nav_en, u8_l cfe_en)
+int rwnx_send_set_temp_comp_req(struct rwnx_hw *rwnx_hw, struct mm_set_vendor_swconfig_cfm *cfm)
 {
-    struct mm_set_txop_req *req;
-    int error;
-
-    /* Build the MM_SET_TXOP_REQ message */
-    req = rwnx_msg_zalloc(MM_SET_TXOP_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_txop_req));
-
-    if (!req) {
-            return -ENOMEM;
-    }
-
-    req->txop_bk = txop[0];
-    req->txop_be = txop[1];
-    req->txop_vi = txop[2];
-    req->txop_vo = txop[3];
-    req->long_nav_en = long_nav_en;
-    req->cfe_en = cfe_en;
-
-    /* Send the MM_SET_TXOP_REQ  message to UMAC FW */
-    error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_TXOP_CFM, NULL);
-
-    return error;
-}
-
-int rwnx_send_vendor_trx_param_req(struct rwnx_hw *rwnx_hw, uint32_t *edca, uint8_t vif_idx, uint8_t retry_cnt)
-{
-	struct mm_set_vendor_trx_param_req *req;
-	int error;
+	struct mm_set_vendor_swconfig_req *req;
+	int ret;
 
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
-
-	/* Build the MM_SET_VENDOR_TRX_PARAM_REQ message */
-    req = rwnx_msg_zalloc(MM_SET_VENDOR_TRX_PARAM_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_vendor_trx_param_req));
+	/* Build the TEMP_COMP_SET_REQ message */
+	req = rwnx_msg_zalloc(MM_SET_VENDOR_SWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_vendor_swconfig_req));
 	if (!req) {
-            return -ENOMEM;
-    }
-
-	req->edca[0] = edca[0];
-	req->edca[1] = edca[1];
-	req->edca[2] =  edca[2];
-	req->edca[3] = edca[3];
-	req->vif_idx = vif_idx;
-	req->retry_cnt = retry_cnt;
-
-	/* Send the MM_SET_VENDOR_TRX_PARAM_REQ message to UMAC FW */
-    error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_TRX_PARAM_CFM, NULL);
-
-	return error;
+		printk("%s msg_alloc fail\n", __func__);
+		return -ENOMEM;
+	}
+	req->swconfig_id = TEMP_COMP_SET_REQ;
+	req->temp_comp_set_req.enable = 1;
+	req->temp_comp_set_req.tmr_period_ms = 15 * 1000;
+
+	ret = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, cfm);
+	if (!ret)
+		printk("temp_comp status: %d\n", cfm->temp_comp_set_cfm.status);
+	else {
+		printk("%s msg_fail\n", __func__);
+		return ret;
+	}
+	return ret;
 }
 
-#endif
-int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param)
+int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param, int32_t *param_out)
 {
 	struct mm_set_acs_txop_req *req0;
 	struct mm_set_channel_access_req *req1;
@@ -1327,7 +1300,7 @@ int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id,
 	struct mm_set_cca_threshold_req *req3;
 	struct mm_set_bwmode_req *req4;
 
-	int error;
+	int error = 0;
 
 	switch (hwconfig_id)
 	{
@@ -1365,8 +1338,9 @@ int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id,
 		req1->rc_retry_cnt[0] = param[9];
 		req1->rc_retry_cnt[1] = param[10];
 		req1->rc_retry_cnt[2] = param[11];
-		printk("set_channel_access_req:edca[]= %x %x %x %x\nvif_idx: %x, retry_cnt: %x, rts_en: %x, long_nav_en: %x, cfe_en: %x, rc_retry_cnt: %x:%x:%x\n",
-			req1->edca[0], req1->edca[1], req1->edca[2], req1->edca[3], req1->vif_idx, req1->retry_cnt, req1->rts_en, req1->long_nav_en, req1->cfe_en, req1->rc_retry_cnt[0],req1->rc_retry_cnt[1], req1->rc_retry_cnt[2]);
+		req1->ccademod_th = param[12];
+		printk("set_channel_access_req:edca[]= %x %x %x %x\nvif_idx: %x, retry_cnt: %x, rts_en: %x, long_nav_en: %x, cfe_en: %x, rc_retry_cnt: %x:%x:%x, ccademod_th = %d\n",
+			req1->edca[0], req1->edca[1], req1->edca[2], req1->edca[3], req1->vif_idx, req1->retry_cnt, req1->rts_en, req1->long_nav_en, req1->cfe_en, req1->rc_retry_cnt[0],req1->rc_retry_cnt[1], req1->rc_retry_cnt[2], req1->ccademod_th);
 		/* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
 		error = rwnx_send_msg(rwnx_hw, req1, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
 		break;
@@ -1416,12 +1390,95 @@ int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id,
                 /* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
 		error = rwnx_send_msg(rwnx_hw, req4, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
 		break;
+        case CHIP_TEMP_GET_REQ:
+        if ((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
+            (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW))
+        {
+            struct mm_get_chip_temp_req *req;
+            struct mm_set_vendor_hwconfig_cfm cfm = {0,};
+            /* Build the CHIP_TEMP_GET_REQ message */
+            req = rwnx_msg_zalloc(MM_SET_VENDOR_HWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_get_chip_temp_req));
+            if (!req)
+                return -ENOMEM;
+            req->hwconfig_id = hwconfig_id;
+            /* Send the MM_SET_VENDOR_HWCONFIG_REQ  message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_HWCONFIG_CFM, &cfm);
+            if (!error) {
+                if (param_out) {
+                    param_out[0] = (int32_t)cfm.chip_temp_cfm.degree;
+                }
+                printk("get_chip_temp degree=%d\n", cfm.chip_temp_cfm.degree);
+            } else {
+                printk("get_chip_temp err=%d\n", error);
+            }
+        }
+        break;
 	    default:
 		return -ENOMEM;
 	}
     return error;
 }
 
+int rwnx_send_vendor_swconfig_req(struct rwnx_hw *rwnx_hw, uint32_t swconfig_id, int32_t *param_in, int32_t *param_out)
+{
+    struct mm_set_vendor_swconfig_req *req;
+    struct mm_set_vendor_swconfig_cfm cfm = {0,};
+    int error;
+
+    req = rwnx_msg_zalloc(MM_SET_VENDOR_SWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_vendor_swconfig_req));
+    if (!req) {
+        return -ENOMEM;
+    }
+    req->swconfig_id = swconfig_id;
+
+    switch (swconfig_id)
+    {
+        case BCN_CFG_REQ:
+            /* Build the BCN_CFG_REQ message */
+            req->bcn_cfg_req.tim_bcmc_ignored_enable = (bool_l)param_in[0];
+            printk("bcn_cfg_req: tim_bcmc_ignd=%d\n", req->bcn_cfg_req.tim_bcmc_ignored_enable);
+            /* Send the MM_SET_VENDOR_SWCONFIG_REQ message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, &cfm);
+            if (!error) {
+                param_out[0] = (int32_t)cfm.bcn_cfg_cfm.tim_bcmc_ignored_status;
+                printk("status=%d\n", cfm.bcn_cfg_cfm.tim_bcmc_ignored_status);
+            }
+            break;
+
+        case TEMP_COMP_SET_REQ:
+            /* Build the TEMP_COMP_SET_REQ message */
+            req->temp_comp_set_req.enable = (u8_l)param_in[0];
+            req->temp_comp_set_req.tmr_period_ms = (u32_l)param_in[1];
+            printk("temp_comp_set_req: en=%d, tmr=%x\n",
+                req->temp_comp_set_req.enable, req->temp_comp_set_req.tmr_period_ms);
+            /* Send the MM_SET_VENDOR_SWCONFIG_REQ message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, &cfm);
+            if (!error) {
+                param_out[0] = (int32_t)cfm.temp_comp_set_cfm.status;
+                printk("status=%d\n", cfm.temp_comp_set_cfm.status);
+            }
+            break;
+
+        case TEMP_COMP_GET_REQ:
+            printk("temp_comp_get_req\n");
+            /* Send the MM_SET_VENDOR_SWCONFIG_REQ message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, &cfm);
+            if (!error) {
+                param_out[0] = (int32_t)cfm.temp_comp_get_cfm.status;
+                param_out[1] = (int32_t)cfm.temp_comp_get_cfm.degree;
+                printk("status=%d, degree=%d\n",
+                    cfm.temp_comp_get_cfm.status, cfm.temp_comp_get_cfm.degree);
+            }
+            break;
+
+        default:
+            error = -ENOMEM;
+            break;
+    }
+
+    return error;
+}
+
 int rwnx_send_get_fw_version_req(struct rwnx_hw *rwnx_hw, struct mm_get_fw_version_cfm *cfm)
 {
     void *req;
@@ -2127,11 +2184,13 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
 {
     struct me_sta_add_req *req;
 
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-    u8 *ht_mcs = (u8 *)&params->ht_capa->mcs;
+#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
+    struct link_station_parameters *link_sta_params = &params->link_sta_params;
 #else
-	u8 *ht_mcs = (u8 *)&params->link_sta_params.ht_capa->mcs;
-#endif//HIGH_KERNEL_VERSION
+    struct station_parameters *link_sta_params = params;
+#endif
+
+	u8 *ht_mcs = (u8 *)&link_sta_params->ht_capa->mcs;
 
     int i;
     struct rwnx_vif *rwnx_vif = rwnx_hw->vif_table[inst_nbr];
@@ -2154,30 +2213,14 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
     /* Set parameters for the MM_STA_ADD_REQ message */
     memcpy(&(req->mac_addr.array[0]), mac, ETH_ALEN);
 
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-	req->rate_set.length = params->supported_rates_len;
-#else
-	req->rate_set.length = params->link_sta_params.supported_rates_len;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-
-    for (i = 0; i < req->rate_set.length; i++){
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-		req->rate_set.array[i] = params->supported_rates[i];
-#else
-		req->rate_set.array[i] = params->link_sta_params.supported_rates[i];
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-    	}
+	req->rate_set.length = link_sta_params->supported_rates_len;;
+	for (i = 0; i < link_sta_params->supported_rates_len; i++)
+		req->rate_set.array[i] = link_sta_params->supported_rates[i];
 
     req->flags = 0;
 
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-	if (params->ht_capa) {
-		const struct ieee80211_ht_cap *ht_capa = params->ht_capa;
-#else
-	if (params->link_sta_params.ht_capa) {
-		const struct ieee80211_ht_cap *ht_capa = params->link_sta_params.ht_capa;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-
+	if (link_sta_params->ht_capa) {
+		const struct ieee80211_ht_cap *ht_capa = link_sta_params->ht_capa;
 
         req->flags |= STA_HT_CAPA;
         req->ht_cap.ht_capa_info = cpu_to_le16(ht_capa->cap_info);
@@ -2190,13 +2233,9 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
     }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-    if (params->vht_capa) {
-        const struct ieee80211_vht_cap *vht_capa = params->vht_capa;
-#else
-	if (params->link_sta_params.vht_capa) {
-		const struct ieee80211_vht_cap *vht_capa = params->link_sta_params.vht_capa;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
+    if (link_sta_params->vht_capa) {
+		const struct ieee80211_vht_cap *vht_capa = link_sta_params->vht_capa;
+
         req->flags |= STA_VHT_CAPA;
         req->vht_cap.vht_capa_info = cpu_to_le32(vht_capa->vht_cap_info);
         req->vht_cap.rx_highest = cpu_to_le16(vht_capa->supp_mcs.rx_highest);
@@ -2218,13 +2257,9 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
 #endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-	if (params->he_capa) {
-		const struct ieee80211_he_cap_elem *he_capa = params->he_capa;
-#else
-	if (params->link_sta_params.he_capa) {
-		const struct ieee80211_he_cap_elem *he_capa = params->link_sta_params.he_capa;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
+
+	if (link_sta_params->he_capa) {
+		const struct ieee80211_he_cap_elem *he_capa = link_sta_params->he_capa;
         struct ieee80211_he_mcs_nss_supp *mcs_nss_supp =
                                 (struct ieee80211_he_mcs_nss_supp *)(he_capa + 1);
 
@@ -2272,13 +2307,8 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
         req->flags |= STA_MFP_CAPA;
 
     #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-    if (params->opmode_notif_used) {
-		req->opmode = params->opmode_notif;
-#else
-	if (params->link_sta_params.opmode_notif_used) {
-		req->opmode = params->link_sta_params.opmode_notif;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
+    if (link_sta_params->opmode_notif_used) {
+		req->opmode = link_sta_params->opmode_notif_used;
         req->flags |= STA_OPMOD_NOTIF;
     }
     #endif
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
index 3b2a5c97f9f5..f3ccd71d335d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
@@ -164,7 +164,9 @@ int rwnx_send_get_sta_info_req(struct rwnx_hw *rwnx_hw, u8_l sta_idx, struct mm_
 int rwnx_send_set_stack_start_req(struct rwnx_hw *rwnx_hw, u8_l on, u8_l efuse_valid, u8_l set_vendor_info,
 					u8_l fwtrace_redir_en, struct mm_set_stack_start_cfm *cfm);
 int rwnx_send_txop_req(struct rwnx_hw *rwnx_hw, uint16_t *txop, u8_l long_nav_en, u8_l cfe_en);
-int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param);
+int rwnx_send_set_temp_comp_req(struct rwnx_hw *rwnx_hw, struct mm_set_vendor_swconfig_cfm *cfm);
+int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param, int32_t *param_out);
+int rwnx_send_vendor_swconfig_req(struct rwnx_hw *rwnx_hw, uint32_t swconfig_id, int32_t *param_in, int32_t *param_out);
 
 int rwnx_send_get_fw_version_req(struct rwnx_hw *rwnx_hw, struct mm_get_fw_version_cfm *cfm);
 int rwnx_send_txpwr_idx_req(struct rwnx_hw *rwnx_hw);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
index 5a5b817e8daf..bb7bae5f9e4e 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
@@ -1239,7 +1239,7 @@ static void rwnx_plat_mpif_sel(struct rwnx_plat *rwnx_plat)
 #endif
 }
 #endif
-#ifdef CONFIG_DPD
+#if (defined(CONFIG_DPD) && !defined(CONFIG_FORCE_DPD_CALIB))
 int is_file_exist(char* name)
 {
     char *path = NULL;
@@ -1266,16 +1266,13 @@ int is_file_exist(char* name)
         return 1;
     }
 }
-#endif//CONFIG_DPD
+#endif//CONFIG_DPD && !CONFIG_FORCE_DPD_CALIB
 /**
  * rwnx_plat_patch_load() - Load patch code
  *
  * @rwnx_hw: Main driver data
  */
 #ifdef CONFIG_ROM_PATCH_EN
-
-uint32_t dpd_res[DPD_RESULT_SIZE_8800DC / 4] = {0,};
-
 static int rwnx_plat_patch_load(struct rwnx_hw *rwnx_hw)
 {
     int ret = 0;
@@ -1303,7 +1300,7 @@ static int rwnx_plat_patch_load(struct rwnx_hw *rwnx_hw)
                     return ret;
                 }
             }
-        } else if (chip_sub_id == 1) {
+        } else if (chip_sub_id >= 1) {
             if (testmode == FW_NORMAL_MODE) {
                 ret = aicwf_plat_patch_load_8800dc(rwnx_hw);
                 if (ret) {
@@ -1315,31 +1312,35 @@ static int rwnx_plat_patch_load(struct rwnx_hw *rwnx_hw)
                 #ifdef CONFIG_FORCE_DPD_CALIB
                 if (1) {
                     AICWFDBG(LOGINFO, "dpd calib & write\n");
-                    ret = aicwf_dpd_calib_8800dc(rwnx_hw, &dpd_res[0]);
+                    ret = aicwf_dpd_calib_8800dc(rwnx_hw, &dpd_res);
                     if (ret) {
                         AICWFDBG(LOGINFO, "dpd calib fail: %d\n", ret);
                         return ret;
                     }
-                    ret = aicwf_dpd_result_write_8800dc((void *)dpd_res, DPD_RESULT_SIZE_8800DC);
-                    if (ret) {
-                        AICWFDBG(LOGINFO, "file write fail: %d\n", ret);
-                        return ret;
-                    }
                 }
                 #else
                 if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 1) {
                     AICWFDBG(LOGINFO, "dpd bin load\n");
-                    ret = aicwf_dpd_result_load_8800dc(rwnx_hw);
+                    ret = aicwf_dpd_result_load_8800dc(rwnx_hw, &dpd_res);
                     if (ret) {
                         AICWFDBG(LOGINFO, "load dpd bin fail: %d\n", ret);
                         return ret;
                     }
+                    ret = aicwf_dpd_result_apply_8800dc(rwnx_hw, &dpd_res);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "apply dpd bin fail: %d\n", ret);
+                        return ret;
+                    }
                 }
                 #endif
                 else
                 #endif
                 {
-                    aicwf_misc_ram_init_8800dc(rwnx_hw);
+                    ret = aicwf_misc_ram_init_8800dc(rwnx_hw);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "misc ram init fail: %d\n", ret);
+                        return ret;
+                    }
                 }
             } else if (testmode == FW_RFTEST_MODE) {
                 #ifdef CONFIG_DPD
@@ -1353,16 +1354,11 @@ static int rwnx_plat_patch_load(struct rwnx_hw *rwnx_hw)
                     }
                     //aicwf_patch_config_8800dc(rwnx_hw);
                     AICWFDBG(LOGINFO, "dpd calib & write\n");
-                    ret = aicwf_dpd_calib_8800dc(rwnx_hw, &dpd_res[0]);
+                    ret = aicwf_dpd_calib_8800dc(rwnx_hw, &dpd_res);
                     if (ret) {
                         AICWFDBG(LOGINFO, "dpd calib fail: %d\n", ret);
                         return ret;
                     }
-                    ret = aicwf_dpd_result_write_8800dc((void *)dpd_res, DPD_RESULT_SIZE_8800DC);
-                    if (ret) {
-                        AICWFDBG(LOGINFO, "file write fail: %d\n", ret);
-                        return ret;
-                    }
                 }
                 #endif
                 #endif
@@ -1372,18 +1368,9 @@ static int rwnx_plat_patch_load(struct rwnx_hw *rwnx_hw)
                     AICWFDBG(LOGINFO, "load rftest bin fail: %d\n", ret);
                     return ret;
                 }
-                #if 0//def CONFIG_DPD//after rftest running
-                if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 1) {
-                    AICWFDBG(LOGINFO, "%s load dpd bin\n", __func__);
-                    ret = aicwf_dpd_result_load_8800dc(rwnx_hw);
-                    if (ret) {
-                        AICWFDBG(LOGINFO, "load dpd bin fail: %d\n", ret);
-                        return ret;
-                    }
-                }
-                #endif
+                /* Note: apply dpd_res after rftest running */
             } else if (testmode == FW_DPDCALIB_MODE) {
-                #ifdef CONFIG_DPD
+                #if (defined(CONFIG_DPD) && !defined(CONFIG_FORCE_DPD_CALIB))
                 if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 0) {
                     AICWFDBG(LOGINFO, "patch load\n");
                     ret = aicwf_plat_patch_load_8800dc(rwnx_hw);
@@ -1393,12 +1380,12 @@ static int rwnx_plat_patch_load(struct rwnx_hw *rwnx_hw)
                     }
                     //aicwf_patch_config_8800dc(rwnx_hw);
                     AICWFDBG(LOGINFO, "dpd calib & write\n");
-                    ret = aicwf_dpd_calib_8800dc(rwnx_hw, &dpd_res[0]);
+                    ret = aicwf_dpd_calib_8800dc(rwnx_hw, &dpd_res);
                     if (ret) {
                         AICWFDBG(LOGINFO, "dpd calib fail: %d\n", ret);
                         return ret;
                     }
-                    ret = aicwf_dpd_result_write_8800dc((void *)dpd_res, DPD_RESULT_SIZE_8800DC);
+                    ret = aicwf_dpd_result_write_8800dc((void *)&dpd_res, DPD_RESULT_SIZE_8800DC);
                     if (ret) {
                         AICWFDBG(LOGINFO, "file write fail: %d\n", ret);
                         return ret;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
index 90e5984fb41f..43f6b313fa7d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
@@ -34,8 +34,8 @@
 #endif
 
 #define RWNX_FCU_FW_NAME                "fcuram.bin"
-#ifdef CONFIG_DPD
-#define FW_DPDRESULT_NAME_8800DC        "aic_dpdresult_8800dc.bin"
+#if (defined(CONFIG_DPD) && !defined(CONFIG_FORCE_DPD_CALIB))
+#define FW_DPDRESULT_NAME_8800DC        "aic_dpdresult_lite_8800dc.bin"
 #endif
 
 enum {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
index b3e0a80649ea..41a1e13e90fc 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
@@ -414,6 +414,12 @@ static void rwnx_rx_data_skb_forward(struct rwnx_hw *rwnx_hw, struct rwnx_vif *r
 	rx_skb->protocol = eth_type_trans(rx_skb, rwnx_vif->ndev);
 	memset(rx_skb->cb, 0, sizeof(rx_skb->cb));
 	REG_SW_SET_PROFILING(rwnx_hw, SW_PROF_IEEE80211RX);
+
+
+#ifdef CONFIG_FILTER_TCP_ACK
+	filter_rx_tcp_ack(rwnx_hw, rx_skb->data, cpu_to_le16(rx_skb->len));
+#endif
+
 	#ifdef CONFIG_RX_NETIF_RECV_SKB //modify by aic
 	local_bh_disable();
 	netif_receive_skb(rx_skb);
@@ -458,14 +464,8 @@ static bool rwnx_rx_data_skb(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
 
     if (amsdu) {
         int count;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0)
         ieee80211_amsdu_to_8023s(skb, &list, rwnx_vif->ndev->dev_addr,
                                  RWNX_VIF_TYPE(rwnx_vif), 0, NULL, NULL);
-#else
-	// for mainline linux commit 986e43b19ae9176093da35e0a844e65c8bf9ede7
-        ieee80211_amsdu_to_8023s(skb, &list, rwnx_vif->ndev->dev_addr,
-                                 RWNX_VIF_TYPE(rwnx_vif), 0, NULL, NULL, false);
-#endif
 
         count = skb_queue_len(&list);
         if (count > ARRAY_SIZE(rwnx_hw->stats.amsdus_rx))
@@ -595,6 +595,12 @@ static bool rwnx_rx_data_skb(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
 #endif
             memset(rx_skb->cb, 0, sizeof(rx_skb->cb));
             REG_SW_SET_PROFILING(rwnx_hw, SW_PROF_IEEE80211RX);
+
+
+#ifdef CONFIG_FILTER_TCP_ACK
+            filter_rx_tcp_ack(rwnx_hw, rx_skb->data, cpu_to_le16(rx_skb->len));
+#endif
+
             #ifdef CONFIG_RX_NETIF_RECV_SKB //modify by aic
             local_bh_disable();
             netif_receive_skb(rx_skb);
@@ -1241,7 +1247,11 @@ static int rwnx_rx_monitor(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
     skb->ip_summed = CHECKSUM_UNNECESSARY;
     skb->pkt_type = PACKET_OTHERHOST;
     skb->protocol = htons(ETH_P_802_2);
-    
+
+#ifdef CONFIG_FILTER_TCP_ACK
+    filter_rx_tcp_ack(rwnx_hw, skb->data, cpu_to_le16(skb->len));
+#endif
+
     local_bh_disable();
     netif_receive_skb(skb);
     local_bh_enable();
@@ -1537,6 +1547,10 @@ int reord_single_frame_ind(struct aicwf_rx_priv *rx_priv, struct recv_msdu *prfr
 #endif
     memset(skb->cb, 0, sizeof(skb->cb));
 
+#ifdef CONFIG_FILTER_TCP_ACK
+     filter_rx_tcp_ack(rwnx_vif->rwnx_hw, skb->data, cpu_to_le16(skb->len));
+#endif
+
 #ifdef CONFIG_RX_NETIF_RECV_SKB//AIDEN test
     local_bh_disable();
 	netif_receive_skb(skb);
@@ -1776,6 +1790,7 @@ int reord_process_unit(struct aicwf_rx_priv *rx_priv, struct sk_buff *skb, u16 s
 
     spin_lock_bh(&preorder_ctrl->reord_list_lock);
     if (reord_need_check(preorder_ctrl, pframe->seq_num)) {
+#if 0
 		if(pframe->rx_data[42] == 0x80){//this is rtp package
 			if(pframe->seq_num == preorder_ctrl->ind_sn){
 				printk("%s pframe->seq_num1:%d \r\n", __func__, pframe->seq_num);
@@ -1792,6 +1807,9 @@ int reord_process_unit(struct aicwf_rx_priv *rx_priv, struct sk_buff *skb, u16 s
 			//printk("%s pframe->seq_num2:%d \r\n", __func__, pframe->seq_num);
 			reord_single_frame_ind(rx_priv, pframe);//not need to reorder
 		}
+#else
+        reord_single_frame_ind(rx_priv, pframe);//not need to reor
+#endif
 
         spin_unlock_bh(&preorder_ctrl->reord_list_lock);
 		return 0;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
index 5e3ac1e83184..689fb9a85624 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
@@ -1227,6 +1227,176 @@ int aic_br_client_tx(struct rwnx_vif *vif, struct sk_buff **pskb)
 #endif /* CONFIG_BR_SUPPORT */
 
 
+#ifdef CONFIG_FILTER_TCP_ACK
+/* return:
+ *      0, msg buf freed by the real driver
+ *      others, skb need free by the caller,remember not use msg->skb!
+ */
+
+int intf_tx(struct rwnx_hw *priv,struct msg_buf *msg)
+{
+	struct rwnx_vif *rwnx_vif = msg->rwnx_vif;
+	struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
+	struct rwnx_txhdr *txhdr;
+	struct rwnx_sw_txhdr *sw_txhdr;
+	struct txdesc_api *desc;
+	struct rwnx_sta *sta;
+	struct rwnx_txq *txq;
+	int headroom;
+	//int max_headroom;
+	int hdr_pads;
+
+	u16 frame_len;
+	u16 frame_oft;
+	u8 tid;
+	struct sk_buff *skb=msg->skb;
+	struct ethhdr eth_t;
+
+	move_tcpack_msg(rwnx_hw,msg);
+	kfree(msg);
+
+	memcpy(&eth_t, skb->data, sizeof(struct ethhdr));
+
+	/* Get the STA id and TID information */
+	sta = rwnx_get_tx_priv(rwnx_vif, skb, &tid);
+	if (!sta)
+		goto free;
+
+	txq = rwnx_txq_sta_get(sta, tid, rwnx_hw);
+	if (txq->idx == TXQ_INACTIVE)
+		goto free;
+
+#ifdef CONFIG_RWNX_AMSDUS_TX
+	if (rwnx_amsdu_add_subframe(rwnx_hw, skb, sta, txq))
+		return NETDEV_TX_OK;
+#endif
+
+#ifdef CONFIG_BR_SUPPORT
+		 if (1) {//(check_fwstate(&padapter->mlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE) == _TRUE) {
+			 void *br_port = NULL;
+
+	#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+			 br_port = rwnx_vif->ndev->br_port;
+	#else
+			 rcu_read_lock();
+			 br_port = rcu_dereference(rwnx_vif->ndev->rx_handler_data);
+			 rcu_read_unlock();
+	#endif
+
+			 if (br_port) {
+				 s32 res = aic_br_client_tx(rwnx_vif, &skb);
+				 if (res == -1) {
+					 goto free;
+				 }
+			 }
+		 }
+#endif /* CONFIG_BR_SUPPORT */
+
+
+	/* Retrieve the pointer to the Ethernet data */
+	// eth = (struct ethhdr *)skb->data;
+
+	skb_pull(skb, 14);
+	//hdr_pads	= RWNX_SWTXHDR_ALIGN_PADS((long)eth);
+	hdr_pads  = RWNX_SWTXHDR_ALIGN_PADS((long)skb->data);
+	headroom  = sizeof(struct rwnx_txhdr) + hdr_pads;
+
+	skb_push(skb, headroom);
+
+	txhdr = (struct rwnx_txhdr *)skb->data;
+	sw_txhdr = kmem_cache_alloc(rwnx_hw->sw_txhdr_cache, GFP_ATOMIC);
+	if (unlikely(sw_txhdr == NULL))
+		goto free;
+	txhdr->sw_hdr = sw_txhdr;
+	desc = &sw_txhdr->desc;
+
+	frame_len = (u16)skb->len - headroom;// - sizeof(*eth);
+
+	sw_txhdr->txq		= txq;
+	sw_txhdr->frame_len = frame_len;
+	sw_txhdr->rwnx_sta	= sta;
+	sw_txhdr->rwnx_vif	= rwnx_vif;
+	sw_txhdr->skb		= skb;
+	sw_txhdr->headroom	= headroom;
+	sw_txhdr->map_len	= skb->len - offsetof(struct rwnx_txhdr, hw_hdr);
+
+#ifdef CONFIG_RWNX_AMSDUS_TX
+	sw_txhdr->amsdu.len = 0;
+	sw_txhdr->amsdu.nb = 0;
+#endif
+	// Fill-in the descriptor
+	memcpy(&desc->host.eth_dest_addr, eth_t.h_dest, ETH_ALEN);
+	memcpy(&desc->host.eth_src_addr, eth_t.h_source, ETH_ALEN);
+	desc->host.ethertype = eth_t.h_proto;
+	desc->host.staid = sta->sta_idx;
+	desc->host.tid = tid;
+	if (unlikely(rwnx_vif->wdev.iftype == NL80211_IFTYPE_AP_VLAN))
+		desc->host.vif_idx = rwnx_vif->ap_vlan.master->vif_index;
+	else
+		desc->host.vif_idx = rwnx_vif->vif_index;
+
+	if (rwnx_vif->use_4addr && (sta->sta_idx < NX_REMOTE_STA_MAX))
+		desc->host.flags = TXU_CNTRL_USE_4ADDR;
+	else
+		desc->host.flags = 0;
+
+	if ((rwnx_vif->tdls_status == TDLS_LINK_ACTIVE) &&
+		rwnx_vif->sta.tdls_sta &&
+		(memcmp(desc->host.eth_dest_addr.array, rwnx_vif->sta.tdls_sta->mac_addr, ETH_ALEN) == 0)) {
+		desc->host.flags |= TXU_CNTRL_TDLS;
+		rwnx_vif->sta.tdls_sta->tdls.last_tid = desc->host.tid;
+		//rwnx_vif->sta.tdls_sta->tdls.last_sn = desc->host.sn;
+	}
+
+	if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_MESH_POINT) {
+		if (rwnx_vif->is_resending) {
+			desc->host.flags |= TXU_CNTRL_MESH_FWD;
+		}
+	}
+
+#ifdef CONFIG_RWNX_SPLIT_TX_BUF
+	desc->host.packet_len[0] = frame_len;
+#else
+	desc->host.packet_len = frame_len;
+#endif
+
+	txhdr->hw_hdr.cfm.status.value = 0;
+
+	if (unlikely(rwnx_prep_tx(rwnx_hw, txhdr))) {
+		kmem_cache_free(rwnx_hw->sw_txhdr_cache, sw_txhdr);
+		skb_pull(skb, headroom);
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_BUSY;
+	}
+
+	/* Fill-in TX descriptor */
+	frame_oft = sizeof(struct rwnx_txhdr) - offsetof(struct rwnx_txhdr, hw_hdr)
+				+ hdr_pads;// + sizeof(*eth);
+#if 0
+#ifdef CONFIG_RWNX_SPLIT_TX_BUF
+	desc->host.packet_addr[0] = sw_txhdr->dma_addr + frame_oft;
+	desc->host.packet_cnt = 1;
+#else
+	desc->host.packet_addr = sw_txhdr->dma_addr + frame_oft;
+#endif
+#endif
+	//desc->host.hostid = sw_txhdr->dma_addr;
+
+	spin_lock_bh(&rwnx_hw->tx_lock);
+	if (rwnx_txq_queue_skb(skb, txq, rwnx_hw, false))
+		rwnx_hwq_process(rwnx_hw, txq->hwq);
+	spin_unlock_bh(&rwnx_hw->tx_lock);
+
+	return 0;//NETDEV_TX_OK
+
+free:
+	dev_kfree_skb_any(skb);
+
+	return 0;//NETDEV_TX_OK
+}
+#endif
+
+
 /**
  * netdev_tx_t (*ndo_start_xmit)(struct sk_buff *skb,
  *                               struct net_device *dev);
@@ -1257,12 +1427,14 @@ netdev_tx_t rwnx_start_xmit(struct sk_buff *skb, struct net_device *dev)
     u8 tid;
     
     struct ethhdr eth_t;
+#ifdef CONFIG_FILTER_TCP_ACK
+    struct msg_buf *msgbuf;
+#endif
 
 #ifdef CONFIG_ONE_TXQ
     skb->queue_mapping = rwnx_select_txq(rwnx_vif, skb);
 #endif
 
-    memcpy(&eth_t, skb->data, sizeof(struct ethhdr));
 
     sk_pacing_shift_update(skb->sk, rwnx_hw->tcp_pacing_shift);
     max_headroom = sizeof(struct rwnx_txhdr);
@@ -1280,6 +1452,19 @@ netdev_tx_t rwnx_start_xmit(struct sk_buff *skb, struct net_device *dev)
         skb = newskb;
     }
 
+#ifdef CONFIG_FILTER_TCP_ACK
+        msgbuf=intf_tcp_alloc_msg(msgbuf);
+        msgbuf->rwnx_vif=rwnx_vif;
+        msgbuf->skb=skb;
+        if(filter_send_tcp_ack(rwnx_hw,msgbuf,skb->data,cpu_to_le16(skb->len))){
+            return NETDEV_TX_OK;
+        }else{
+            move_tcpack_msg(rwnx_hw,msgbuf);
+            kfree(msgbuf);
+        }
+#endif
+    memcpy(&eth_t, skb->data, sizeof(struct ethhdr));
+
     /* Get the STA id and TID information */
     sta = rwnx_get_tx_priv(rwnx_vif, skb, &tid);
     if (!sta)
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c
index 7ffb99e845e4..5b7159725f3d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c
@@ -1256,7 +1256,9 @@ void rwnx_hwq_process(struct rwnx_hw *rwnx_hw, struct rwnx_hwq *hwq)
         /* sanity check for debug */
         BUG_ON(!(txq->status & RWNX_TXQ_IN_HWQ_LIST));
 		if(txq->idx == TXQ_INACTIVE){
-			printk("%s txq->idx == TXQ_INACTIVE \r\n", __func__);
+			AICWFDBG(LOGERROR, "%s txq->idx == TXQ_INACTIVE \r\n", __func__);
+            rwnx_txq_del_from_hw_list(txq);
+            rwnx_txq_flush(rwnx_hw, txq);            
 			continue;
 		}
         BUG_ON(txq->idx == TXQ_INACTIVE);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h
index e41185bd4a88..402fb3905269 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h
@@ -15,12 +15,6 @@
 #include "lmac_msg.h"
 #include "aicwf_debug.h"
 
-#ifdef ANDROID_PLATFORM 
-#define HIGH_KERNEL_VERSION KERNEL_VERSION(5, 15, 41)
-#else
-#define HIGH_KERNEL_VERSION KERNEL_VERSION(6, 0, 0)
-#endif
-
 
 #if 0
 #ifdef CONFIG_RWNX_DBG
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
index 587304391aca..101cc24dec9d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
@@ -1,5 +1,5 @@
 #define RWNX_VERS_REV "1a4b0054d2M (master)"
 #define RWNX_VERS_MOD "6.4.3.0"
 #define RWNX_VERS_BANNER "rwnx v6.4.3.0 - 1a4b0054d2M (master)"
-#define RELEASE_DATE "2023_0904_1727"
+#define RELEASE_DATE "2023_1212_15dcf017"
 
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/.gitignore b/drivers/net/wireless/aic8800/aic_load_fw/.gitignore
new file mode 100644
index 000000000000..6ebacd59953a
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic_load_fw/.gitignore
@@ -0,0 +1,11 @@
+*.o
+*.ko
+*.order
+*.symvers
+*.o.d
+*.o.cmd
+*.ko.cmd
+*.mod
+*.mod.c*
+
+.tmp_versions/
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/Makefile b/drivers/net/wireless/aic8800/aic_load_fw/Makefile
index 6a94b3c5efde..f3cfac5341a9 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/Makefile
+++ b/drivers/net/wireless/aic8800/aic_load_fw/Makefile
@@ -54,13 +54,12 @@ ccflags-$(CONFIG_PLATFORM_ROCKCHIP) += -DCONFIG_PLATFORM_ROCKCHIP
 #KDIR := /home/yaya/E/Rockchip/3229/Android7/RK3229_ANDROID7.1_v1.01_20170914/rk3229_Android7.1_v1.01_xml0914/kernel
 #ARCH ?= arm
 #CROSS_COMPILE ?= /home/yaya/E/Rockchip/3229/Android7/RK3229_ANDROID7.1_v1.01_20170914/rk3229_Android7.1_v1.01_xml0914/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
+KDIR  := /home/yaya/E/Rockchip/3229/Android9/rk3229_android9.0_box/kernel
+ARCH ?= arm
+CROSS_COMPILE ?= /home/yaya/E/Rockchip/3229/Android9/rk3229_android9.0_box/prebuilts/gcc/linux-x86/arm/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
 #KDIR  := /home/yaya/E/Rockchip/3399/rk3399-android-10/kernel
 #ARCH ?= arm64
 #CROSS_COMPILE ?= /home/yaya/E/Rockchip/3399/rk3399-android-10/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
-ARCH := arm64
-KDIR ?= /home/yaya/E/Rockchip/3566/firefly/Android11.0/Firefly-RK356X_Android11.0_git_20210824/RK356X_Android11.0/kernel
-CROSS_COMPILE := /home/yaya/E/Rockchip/3566/firefly/Android11.0/Firefly-RK356X_Android11.0_git_20210824/RK356X_Android11.0/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
-
 endif
 
 ifeq ($(CONFIG_PLATFORM_ALLWINNER), y)
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_bluetooth_main.c b/drivers/net/wireless/aic8800/aic_load_fw/aic_bluetooth_main.c
index d7cb48fc9704..9d1442d2d2fc 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aic_bluetooth_main.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_bluetooth_main.c
@@ -1,5 +1,7 @@
 #include <linux/module.h>
 #include <linux/inetdevice.h>
+#include <linux/version.h>
+
 #include "aicwf_usb.h"
 #include "rwnx_version_gen.h"
 #include "aicwf_rx_prealloc.h"
@@ -19,6 +21,7 @@ char paringid[100];
 int n_para = 1;
 int ble_scan_wakeup_reboot_time = 1000;
 int aicwf_dbg_level = LOGERROR|LOGINFO|LOGDEBUG|LOGTRACE;
+int flash_erase_len = 0x400000;
 uint32_t ad_data_filter_mask = 0;
 uint32_t gpio_num = 2;//default select gpiob2 for fw_wakeup_host
 uint32_t gpio_dft_lvl = 0;//0:defalut pull down,  1:default pull up
@@ -28,6 +31,7 @@ module_param(ble_scan_wakeup_reboot_time, int, 0660);
 module_param(testmode, int, 0660);
 module_param(adap_test, int, 0660);
 module_param_string(paringid, paringid, 100, 0660);
+module_param(flash_erase_len, int, 0660);
 
 
 static void aicsmac_driver_register(void)
@@ -65,6 +69,10 @@ static void __exit aic_bluetooth_mod_exit(void)
 module_init(aic_bluetooth_mod_init);
 module_exit(aic_bluetooth_mod_exit);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
+#endif
+
 MODULE_FIRMWARE(DRV_CONFIG_FW_NAME);
 MODULE_DESCRIPTION(DRV_DESCRIPTION);
 MODULE_VERSION(DRV_VERS_MOD);
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.c b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.c
index fc8281c92548..b1859370a537 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.c
@@ -17,6 +17,7 @@ void rwnx_release_firmware_common(u32** buffer);
 
 extern int testmode;
 extern int chip_id;
+u8 chip_mcu_id = 0;
 
 typedef u32 (*array2_tbl_t)[2];
 
@@ -45,6 +46,7 @@ u32 patch_tbl_d80[][2] =
     #else
     {0x00b4, 0xf3010000},
     #endif
+    {0x0170, 0x00000001},//rx aggr counter
 };
 
 //adap test
@@ -80,6 +82,7 @@ int aicwf_patch_config_8800d80(struct aic_usb_dev *usb_dev)
     int adap_patch_cnt = 0;
 
     if (adap_test) {
+        AICWFDBG(LOGINFO, "%s adap test \r\n", __func__);
         adap_patch_cnt = sizeof(adaptivity_patch_tbl_d80)/sizeof(u32)/2;
     }
 
@@ -229,8 +232,11 @@ int system_config_8800d80(struct aic_usb_dev *usb_dev){
 			printk("%x rd fail: %d\n", mem_addr, ret);
 			return ret;
 		}
+        if (((rd_mem_addr_cfm.memdata >> 25) & 0x01UL) == 0x00UL) {
+            chip_mcu_id = 1;
+        }
 		chip_id = (u8)(rd_mem_addr_cfm.memdata >> 16);
-		printk("chip_id=%x\n", chip_id);
+		printk("chip_id=%x, chip_mcu_id = %d\n", chip_id, chip_mcu_id);
     #if 1
 		syscfg_num = sizeof(syscfg_tbl_8800d80) / sizeof(u32) / 2;
 		for (cnt = 0; cnt < syscfg_num; cnt++) {
@@ -254,7 +260,6 @@ int system_config_8800d80(struct aic_usb_dev *usb_dev){
 }
 
 
-
 int aicfw_download_fw_8800d80(struct aic_usb_dev *usb_dev)
 {
     struct aicbt_patch_table *head = NULL;
@@ -377,6 +382,15 @@ int aicfw_download_fw_8800d80(struct aic_usb_dev *usb_dev)
             }
 #endif
 
+            if (chip_mcu_id) {
+                int ret = 0;
+                ret = rwnx_plat_flash_bin_upload_android(usb_dev, FLASH_BIN_ADDR_8800M80, FLASH_BIN_8800M80);
+                if (ret && ret!= ENOENT) {
+                    AICWFDBG(LOGERROR,"%s flash bin download fail \r\n", __func__);
+                    return -1;
+                }
+            }
+
 			if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80_U02, FW_RF_BASE_NAME_8800D80_U02)) {
 				AICWFDBG(LOGERROR,"%s wifi fw download fail \r\n", __func__);
 				return -1;
@@ -406,29 +420,86 @@ int aicfw_download_fw_8800d80(struct aic_usb_dev *usb_dev)
             data & mask = "0x46 0x00" 0x00 0x00 0x00 0x00 0x00 0x00 0x00 "0x30 0xff 0xff 0x43 0x52 0x45 0x4c 0x42"
             using data & mask value condition to wakeup host_wake_bt gpio
 */
-            const uint8_t data[18] = {0x46,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x30,0xff,0xff,0xff,0x43,0x52,0x45,0x4c,0x42};
-            struct ad_data_filter* ad_data = (struct ad_data_filter*)kmalloc(sizeof(struct ad_data_filter), GFP_KERNEL);
-            uint32_t *write_blocks = (uint32_t *)ad_data;
-            
-	        printk("%s ble scan wakeup \r\n", __func__);
+            struct ble_wakeup_param_t* wakeup_param = (struct ble_wakeup_param_t*)kmalloc(sizeof(struct ble_wakeup_param_t), GFP_KERNEL);
+            uint32_t *write_blocks = (uint32_t *)wakeup_param;
+
+            printk("%s ble scan wakeup \r\n", __func__);
 
-            memset(ad_data, 0, sizeof(struct ad_data_filter));
+            memset(wakeup_param, 0, sizeof(struct ble_wakeup_param_t));
             rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FW_BLE_SCAN_WAKEUP_ADDR_8800D80, FW_BLE_SCAN_AD_FILTER_NAME);
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF00, 0x53454C42);//magic_num
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF04, ble_scan_wakeup_reboot_time);//reboot time
-            ad_data->ad_len = 0x13;
-            ad_data->ad_type = 0xff;
-            memcpy(ad_data->ad_data, data,ad_data->ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
-            ad_data_filter_mask = 0xc07fc000;
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF08, ad_data_filter_mask);//reboot time
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF0c, gpio_num);////default select gpiob2 for fw_wakeup_host
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF10, gpio_dft_lvl);////0:defalut pull down,  1:default pull up
-            for(i = 0; i < 9; i++){
+            wakeup_param->magic_num = 0x53454C42;//magic_num
+            wakeup_param->delay_scan_to = 1000;//delay start scan time(ms)
+            wakeup_param->reboot_to = ble_scan_wakeup_reboot_time;//reboot time
+            /******************************************************************/
+            ///gpio_trigger_idx : 0    if wakeup_param->gpio_dft_lvl[0]=0xfe,this idx will be invalid.
+            wakeup_param->gpio_num[0] = gpio_num;////default select gpiob2 for fw_wakeup_host
+            wakeup_param->gpio_dft_lvl[0] = gpio_dft_lvl;////0:defalut pull down,  1:default pull up
+            ///gpio_trigger_idx : 1    if wakeup_param->gpio_dft_lvl[1]=0xfe,this idx will be invalid.
+            wakeup_param->gpio_num[1] = 3;////default select gpiob2 for fw_wakeup_host
+            wakeup_param->gpio_dft_lvl[1] = 1;////0:defalut pull down,  1:default pull up
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 0
+            {
+                const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[0].ad_len = 12;
+                wakeup_param->ad_filter[0].ad_type = 0x09;
+                memcpy(wakeup_param->ad_filter[0].ad_data, data,wakeup_param->ad_filter[0].ad_len-1);// 1111 1111 1110 0000 0000 0000 0000 0000 //0xffe00000
+                wakeup_param->ad_filter[0].ad_data_mask = 0xffe00000;
+                wakeup_param->ad_filter[0].ad_role = ROLE_COMBO|(COMBO_0<<4);
+                wakeup_param->ad_filter[0].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 1
+            {
+                const uint8_t data[2] = {0x12,0x18};
+                wakeup_param->ad_filter[1].ad_len = 3;
+                wakeup_param->ad_filter[1].ad_type = 0x3;
+                memcpy(wakeup_param->ad_filter[1].ad_data, data,wakeup_param->ad_filter[1].ad_len-1);// 1100 0000 0000 0000 0000 0000 0000 0000 //0xc0000000
+                wakeup_param->ad_filter[1].ad_data_mask = 0xc0000000;
+                wakeup_param->ad_filter[1].ad_role = ROLE_COMBO|(COMBO_0<<4);
+                wakeup_param->ad_filter[1].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 2
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[2].ad_len = 0;
+                wakeup_param->ad_filter[2].ad_type = 0;
+                //memcpy(wakeup_param->ad_filter[2].ad_data, data,wakeup_param->ad_filter[2].ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
+                wakeup_param->ad_filter[2].ad_data_mask = 0;
+                wakeup_param->ad_filter[2].ad_role = ROLE_ONLY;
+                wakeup_param->ad_filter[2].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 3
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[3].ad_len = 0;
+                wakeup_param->ad_filter[3].ad_type = 0;
+                //memcpy(wakeup_param->ad_filter[2].ad_data, data,wakeup_param->ad_filter[2].ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
+                wakeup_param->ad_filter[3].ad_data_mask = 0;
+                wakeup_param->ad_filter[3].ad_role = ROLE_COMBO|(COMBO_1<<4);
+                wakeup_param->ad_filter[3].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 4
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[4].ad_len = 0;
+                wakeup_param->ad_filter[4].ad_type = 0x09;
+                //memcpy(wakeup_param->ad_filter[4].ad_data, data,wakeup_param->ad_filter[4].ad_len-1);// 1111 1111 1110 0000 0000 0000 0000 0000 //0xffe00000
+                wakeup_param->ad_filter[4].ad_data_mask = 0xffe00000;
+                wakeup_param->ad_filter[4].ad_role = ROLE_COMBO|(COMBO_1<<4);
+                wakeup_param->ad_filter[4].gpio_trigger_idx = TG_IDX_0|TG_IDX_1;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+
+            for(i = 0; i < (sizeof(struct ble_wakeup_param_t)/4 +1); i++){
                 printk("write_blocks[%d]:0x%08X \r\n", i, write_blocks[i]);
-                rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF14 + (4 * i), write_blocks[i]);
+                rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF00 + (4 * i), write_blocks[i]);
             }
             rwnx_send_dbg_start_app_req(usb_dev, RAM_FW_BLE_SCAN_WAKEUP_ADDR_8800D80, HOST_START_APP_AUTO);
-            kfree(ad_data);
+            kfree(wakeup_param);
+
             return -1;
         }
     return 0;
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.h b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.h
index 0249f935235f..51a241908802 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.h
@@ -17,6 +17,8 @@
 #define FW_CALIBMODE_NAME_8800D80_U02       "calibmode_8800d80.bin"
 #define FW_PATCH_TABLE_NAME_8800D80_U02     "fw_patch_table_8800d80_u02.bin"
 
+#define FLASH_BIN_8800M80                   "host_wb_8800m80.bin"
+
 #define FW_USERCONFIG_NAME_8800D80          "aic_userconfig_8800d80.txt"
 
 #define RAM_FMAC_FW_ADDR_8800D80           0x100000
@@ -30,6 +32,9 @@
 #define FW_RAM_CALIBMODE_ADDR_8800D80_U02  0x1e0000
 #define FW_RAM_PATCH_BASE_ADDR_8800D80_U02 0x0020B43c
 
+#define FLASH_BIN_ADDR_8800M80             0x8000000
+
+
 int aicwf_patch_config_8800d80(struct aic_usb_dev *usb_dev);
 int rwnx_plat_userconfig_load_8800d80(struct aic_usb_dev *usbdev);
 int system_config_8800d80(struct aic_usb_dev *usb_dev);
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.c b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.c
index 2a47c6d522fb..184d857117ae 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.c
@@ -15,6 +15,8 @@
 #define PRINT 2
 #define GET_VALUE 3
 
+extern int flash_erase_len;
+
 typedef struct
 {
     int8_t enable;
@@ -144,7 +146,7 @@ enum aicbsp_cpmode_type {
 ///aic bt tx pwr lvl :lsb->msb: first byte, min pwr lvl; second byte, max pwr lvl;
 ///pwr lvl:20(min), 30 , 40 , 50 , 60(max)
 #define AICBT_TXPWR_LVL            0x00006020
-#define AICBT_TXPWR_LVL_D80        0x00006F2F
+#define AICBT_TXPWR_LVL_8800d80     0x00006F2F
 
 #define AICBSP_MODE_BT_HCI_MODE_NULL              0
 #define AICBSP_MODE_BT_HCI_MODE_MB                1
@@ -153,20 +155,23 @@ enum aicbsp_cpmode_type {
 #define AICBSP_HWINFO_DEFAULT       (-1)
 #define AICBSP_CPMODE_DEFAULT       AICBSP_CPMODE_WORK
 
-#define AICBT_BTMODE_DEFAULT        AICBT_BTMODE_BT_ONLY
-#define AICBT_BTPORT_DEFAULT        AICBT_BTPORT_MB
-#define AICBT_UART_BAUD_DEFAULT     AICBT_UART_BAUD_1_5M
-#define AICBT_UART_FC_DEFAULT       AICBT_UART_FLOWCTRL_ENABLE
-#define AICBT_LPM_ENABLE_DEFAULT    0
-#define AICBT_TXPWR_LVL_DEFAULT     AICBT_TXPWR_LVL
+#define AICBT_BTMODE_DEFAULT_8800d80        AICBT_BTMODE_BT_ONLY_COANT
+#define AICBT_BTMODE_DEFAULT                AICBT_BTMODE_BT_ONLY
+#define AICBT_BTPORT_DEFAULT                AICBT_BTPORT_MB
+#define AICBT_UART_BAUD_DEFAULT             AICBT_UART_BAUD_1_5M
+#define AICBT_UART_FC_DEFAULT               AICBT_UART_FLOWCTRL_ENABLE
+#define AICBT_LPM_ENABLE_DEFAULT            0
+#define AICBT_TXPWR_LVL_DEFAULT             AICBT_TXPWR_LVL
+#define AICBT_TXPWR_LVL_DEFAULT_8800d80     AICBT_TXPWR_LVL_8800d80
+
 
 #define AIC_HW_INFO 0x21
 
 #define FW_PATH_MAX 200
 #if defined(CONFIG_PLATFORM_UBUNTU)
-static const char* aic_default_fw_path = "/lib/firmware";
+static const char* aic_default_fw_path = "/usr/lib/firmware";
 #else
-static const char* aic_default_fw_path = "/vendor/etc/firmware";
+static const char* aic_default_fw_path = "/usr/lib/firmware";
 #endif
 char aic_fw_path[FW_PATH_MAX];
 module_param_string(aic_fw_path, aic_fw_path, FW_PATH_MAX, 0660);
@@ -656,6 +661,90 @@ int rwnx_plat_m2d_flash_ota_check(struct aic_usb_dev *usbdev, char *filename)
 }
 #endif//CONFIG_M2D_OTA_AUTO_SUPPORT
 
+int rwnx_plat_flash_bin_upload_android(struct aic_usb_dev *usbdev, u32 fw_addr,
+                               char *filename)
+{
+    struct device *dev = usbdev->dev;
+    unsigned int i=0;
+    int size;
+    u32 *dst=NULL;
+    int err=0;
+    const u32 mem_addr = fw_addr;
+    struct dbg_mem_read_cfm rd_mem_addr_cfm;
+
+    /* load aic firmware */
+    size = aic_load_firmware(&dst, filename, dev);
+    if(size<=0){
+            printk("wrong size of firmware file\n");
+            vfree(dst);
+            dst = NULL;
+            return ENOENT;
+    }
+
+    printk("size %x, flash_erase_len %x\n", size, flash_erase_len);
+    if (size != flash_erase_len || (flash_erase_len & 0xFFF)) {
+        printk("wrong size of flash_erase_len %d\n", flash_erase_len);
+        vfree(dst);
+        dst = NULL;
+        return -1;
+    }
+
+    err = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
+    if (err) {
+        printk("%x rd fail: %d\n", mem_addr, err);
+        return err;
+    }
+
+    if (rd_mem_addr_cfm.memdata != 0xffffffff) {
+        //erase flash
+        if (size > 0x40000) {
+            for (i = 0; i < (size - 0x40000); i +=0x40000) {//each time erase 256K
+                err = rwnx_send_dbg_mem_mask_write_req(usbdev, fw_addr+i, 0xf150e250, 0x40000);
+                if (err) {
+                    printk("flash erase fail: %x, err:%d\r\n", fw_addr + i, err);
+                    return err;
+                }
+            }
+        }
+        if (!err && (i < size)) {// <256KB data
+            err = rwnx_send_dbg_mem_mask_write_req(usbdev, fw_addr + i, 0xf150e250, size - i);
+            if (err) {
+                printk("flash erase fail: %x, err:%d\r\n", fw_addr + i, err);
+            }
+        }
+    }
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload %s firmware, @ = %x  size=%d\n", filename, fw_addr, size);
+
+    if (size > 1024) {// > 1KB data
+        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
+            err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, 1024, dst + i / 4);
+                if (err) {
+                printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
+                break;
+            }
+        }
+    }
+
+    if (!err && (i < size)) {// <1KB data
+        err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, size - i, dst + i / 4);
+        if (err) {
+            printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
+        }
+    }
+
+    if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+
+    printk("fw download complete\n\n");
+
+    return err;
+}
+
+
 uint32_t rwnx_atoli(char *value){
 	int len = 0;
 	int temp_len = 0;
@@ -1056,13 +1145,33 @@ struct aicbsp_info_t aicbsp_info = {
     .cpmode   = AICBSP_CPMODE_DEFAULT,
 };
 
-static struct aicbt_info_t aicbt_info = {
-    .btmode        = AICBT_BTMODE_DEFAULT,
-    .btport        = AICBT_BTPORT_DEFAULT,
-    .uart_baud     = AICBT_UART_BAUD_DEFAULT,
-    .uart_flowctrl = AICBT_UART_FC_DEFAULT,
-    .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
-    .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT,
+
+
+static struct aicbt_info_t aicbt_info[] = {
+    {   
+        .btmode        = AICBT_BTMODE_DEFAULT,
+        .btport        = AICBT_BTPORT_DEFAULT,
+        .uart_baud     = AICBT_UART_BAUD_DEFAULT,
+        .uart_flowctrl = AICBT_UART_FC_DEFAULT,
+        .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
+        .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT,
+    },//PRODUCT_ID_AIC8800
+    {
+    },//PRODUCT_ID_AIC8801
+    {
+    },//PRODUCT_ID_AIC8800DC
+    {
+    },//PRODUCT_ID_AIC8800DW
+    {
+        .btmode        = AICBT_BTMODE_DEFAULT_8800d80,
+        .btport        = AICBT_BTPORT_DEFAULT,
+        .uart_baud     = AICBT_UART_BAUD_DEFAULT,
+        .uart_flowctrl = AICBT_UART_FC_DEFAULT,
+        .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
+        .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT_8800d80,
+    },//PRODUCT_ID_AIC8800D80
+    {
+    },//PRODUCT_ID_AIC8800D81
 };
 
 int aicbt_patch_table_load(struct aic_usb_dev *usbdev, struct aicbt_patch_table *_head)
@@ -1072,10 +1181,7 @@ int aicbt_patch_table_load(struct aic_usb_dev *usbdev, struct aicbt_patch_table
 	uint32_t *data = NULL;
 
 	head = _head;
-	if (usbdev->chipid == PRODUCT_ID_AIC8800D80) {
-		//aicbt_info.btmode = AICBT_BTMODE_BT_ONLY_COANT;
-		aicbt_info.txpwr_lvl = AICBT_TXPWR_LVL_D80;
-	}
+
 	for (p = head; p != NULL; p = p->next) {
 		data = p->data;
 		if(AICBT_PT_BTMODE == p->type){
@@ -1083,12 +1189,18 @@ int aicbt_patch_table_load(struct aic_usb_dev *usbdev, struct aicbt_patch_table
 			*(data + 3) = aicbsp_info.hwinfo;
 			*(data + 5)  = aicbsp_info.cpmode;
 
-			*(data + 7) = aicbt_info.btmode;
-			*(data + 9) = aicbt_info.btport;
-			*(data + 11) = aicbt_info.uart_baud;
-			*(data + 13) = aicbt_info.uart_flowctrl;
-			*(data + 15) = aicbt_info.lpm_enable;
-			*(data + 17) = aicbt_info.txpwr_lvl;
+			*(data + 7) = aicbt_info[usbdev->chipid].btmode;
+			*(data + 9) = aicbt_info[usbdev->chipid].btport;
+			*(data + 11) = aicbt_info[usbdev->chipid].uart_baud;
+			*(data + 13) = aicbt_info[usbdev->chipid].uart_flowctrl;
+			*(data + 15) = aicbt_info[usbdev->chipid].lpm_enable;
+			*(data + 17) = aicbt_info[usbdev->chipid].txpwr_lvl;
+            
+            printk("%s bt btmode[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].btmode);
+    		printk("%s bt uart_baud[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].uart_baud);
+    		printk("%s bt uart_flowctrl[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].uart_flowctrl);
+    		printk("%s bt lpm_enable[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].lpm_enable);
+    		printk("%s bt tx_pwr[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].txpwr_lvl);
 
 		}
 		if (p->type == 0x06) {
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.h b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.h
index 32af50e2a5f3..d4af0c72dc4c 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.h
@@ -24,6 +24,7 @@ int rwnx_plat_m2d_flash_ota_check(struct aic_usb_dev *usbdev, char *filename);
 int rwnx_plat_bin_fw_patch_table_upload_android(struct aic_usb_dev *usbdev, char *filename);
 
 int rwnx_plat_userconfig_upload_android(struct aic_usb_dev *usbdev, char *filename);
+int rwnx_plat_flash_bin_upload_android(struct aic_usb_dev *usbdev, u32 fw_addr, char *filename);
 
 int8_t rwnx_atoi(char *value);
 uint32_t rwnx_atoli(char *value);
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.c b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.c
index b18ae9db7404..229b5ceab712 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.c
@@ -12,7 +12,6 @@
  */
 
 #include <linux/list.h>
-// kernel not need include this header
 //#include <stddef.h>
 #include "aicbluetooth_cmds.h"
 #include "aic_txrxif.h"
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_rx_prealloc.c b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_rx_prealloc.c
index c2c7db0886a0..85cfb31513cd 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_rx_prealloc.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_rx_prealloc.c
@@ -11,7 +11,7 @@ struct aicwf_rx_buff_list aic_rx_buff_list;
 
 int aic_rxbuff_num_max = 1000;
 
-int aic_rxbuff_size = (4 * 512) * 10;
+int aic_rxbuff_size = (4 * 512) * 1;
 
 int rx_buff_list_ava = 0;
 
@@ -32,6 +32,7 @@ struct rx_buff *aicwf_prealloc_rxbuff_alloc(spinlock_t *lock)
     if(rx_buff_list_ava < 10){
         AICWFDBG(LOGERROR, "%s WARNING rxbuff is running out %d\r\n", __func__,
             rx_buff_list_ava);
+        msleep(10);
     }
 
     if (list_empty(&aic_rx_buff_list.rxbuff_list)) {
@@ -66,7 +67,7 @@ void aicwf_prealloc_rxbuff_free(struct rx_buff *rxbuff, spinlock_t *lock)
     spin_unlock_irqrestore(lock, flags);
 }
 
-int aicwf_prealloc_init()
+int aicwf_prealloc_init(void)
 {
     struct rx_buff *rxbuff;
     int i = 0;
@@ -97,7 +98,7 @@ int aicwf_prealloc_init()
     return 0;
 }
 
-void aicwf_prealloc_exit()
+void aicwf_prealloc_exit(void)
 {
     struct rx_buff *rxbuff;
     struct rx_buff *pos;
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_txq_prealloc.c b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_txq_prealloc.c
index 585d48c11c20..cca065935f98 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_txq_prealloc.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_txq_prealloc.c
@@ -8,7 +8,7 @@ struct prealloc_txq{
 };
 
 struct prealloc_txq prealloc_txq;
-#define MAX_TXQ_SIZE 30 * 1024
+#define MAX_TXQ_SIZE 100 * 1024
 
 void *aicwf_prealloc_txq_alloc(size_t size)
 {
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.c b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.c
index 499583504f7e..c2136fe8a695 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.c
@@ -33,6 +33,8 @@ extern int testmode;
 extern unsigned char paringid[100];
 extern int ble_scan_wakeup_reboot_time;
 extern uint32_t ad_data_filter_mask;
+extern uint32_t gpio_num;//default select gpiob2 for fw_wakeup_host
+extern uint32_t gpio_dft_lvl;//0:defalut pull down,  1:default pull up
 u8 chip_id = 0;
 u8 chip_sub_id = 0;
 int fw_loaded = 0;
@@ -1409,10 +1411,9 @@ int aicfw_download_fw_8800(struct aic_usb_dev *usb_dev){
             return -1;
 
         } else if(testmode == FW_BLE_SCAN_AD_FILTER_MODE){
-        
 /*
             data and ad_data_filter_mask instructions for use
-            ex. 
+            ex.
             data[18] = {0x46,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x30,0xff,0xff,0xff,0x43,0x52,0x45,0x4c,0x42};
             mask = 1100 0000 0111 1111 1100 0000 0000 0000 = 0xc07fc000
 
@@ -1422,27 +1423,88 @@ int aicfw_download_fw_8800(struct aic_usb_dev *usb_dev){
             data & mask = "0x46 0x00" 0x00 0x00 0x00 0x00 0x00 0x00 0x00 "0x30 0xff 0xff 0x43 0x52 0x45 0x4c 0x42"
             using data & mask value condition to wakeup host_wake_bt gpio
 */
-            const uint8_t data[18] = {0x46,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x30,0xff,0xff,0xff,0x43,0x52,0x45,0x4c,0x42};
-            struct ad_data_filter* ad_data = (struct ad_data_filter*)kmalloc(sizeof(struct ad_data_filter), GFP_KERNEL);
-            uint32_t *write_blocks = (uint32_t *)ad_data;
+            struct ble_wakeup_param_t* wakeup_param = (struct ble_wakeup_param_t*)kmalloc(sizeof(struct ble_wakeup_param_t), GFP_KERNEL);
+            uint32_t *write_blocks = (uint32_t *)wakeup_param;
+
+            printk("%s ble scan wakeup \r\n", __func__);
 
-            memset(ad_data, 0, sizeof(struct ad_data_filter));
+            memset(wakeup_param, 0, sizeof(struct ble_wakeup_param_t));
             rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FW_BLE_SCAN_WAKEUP_ADDR, FW_BLE_SCAN_AD_FILTER_NAME);
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF00, 0x53454C42);//magic_num
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF04, ble_scan_wakeup_reboot_time);//reboot time
-            ad_data->ad_len = 0x13;
-            ad_data->ad_type = 0xff;
-            memcpy(ad_data->ad_data, data,ad_data->ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
-            ad_data_filter_mask = 0xc07fc000;
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF08, ad_data_filter_mask);//reboot time
-            for(i = 0; i < 9; i++){
+            wakeup_param->magic_num = 0x53454C42;//magic_num
+            wakeup_param->delay_scan_to = 1000;//delay start scan time(ms)
+            wakeup_param->reboot_to = ble_scan_wakeup_reboot_time;//reboot time
+            /******************************************************************/
+            ///gpio_trigger_idx : 0    if wakeup_param->gpio_dft_lvl[0]=0xfe,this idx will be invalid.
+            wakeup_param->gpio_num[0] = gpio_num;////default select gpiob2 for fw_wakeup_host
+            wakeup_param->gpio_dft_lvl[0] = gpio_dft_lvl;////0:defalut pull down,  1:default pull up
+            ///gpio_trigger_idx : 1    if wakeup_param->gpio_dft_lvl[1]=0xfe,this idx will be invalid.
+            wakeup_param->gpio_num[1] = 3;////default select gpiob2 for fw_wakeup_host
+            wakeup_param->gpio_dft_lvl[1] = 1;////0:defalut pull down,  1:default pull up
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 0
+            {
+                const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[0].ad_len = 12;
+                wakeup_param->ad_filter[0].ad_type = 0x09;
+                memcpy(wakeup_param->ad_filter[0].ad_data, data,wakeup_param->ad_filter[0].ad_len-1);// 1111 1111 1110 0000 0000 0000 0000 0000 //0xffe00000
+                wakeup_param->ad_filter[0].ad_data_mask = 0xffe00000;
+                wakeup_param->ad_filter[0].ad_role = ROLE_COMBO|(COMBO_0<<4);
+                wakeup_param->ad_filter[0].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 1
+            {
+                const uint8_t data[2] = {0x12,0x18};
+                wakeup_param->ad_filter[1].ad_len = 3;
+                wakeup_param->ad_filter[1].ad_type = 0x3;
+                memcpy(wakeup_param->ad_filter[1].ad_data, data,wakeup_param->ad_filter[1].ad_len-1);// 1100 0000 0000 0000 0000 0000 0000 0000 //0xc0000000
+                wakeup_param->ad_filter[1].ad_data_mask = 0xc0000000;
+                wakeup_param->ad_filter[1].ad_role = ROLE_COMBO|(COMBO_0<<4);
+                wakeup_param->ad_filter[1].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 2
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[2].ad_len = 0;
+                wakeup_param->ad_filter[2].ad_type = 0;
+                //memcpy(wakeup_param->ad_filter[2].ad_data, data,wakeup_param->ad_filter[2].ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
+                wakeup_param->ad_filter[2].ad_data_mask = 0;
+                wakeup_param->ad_filter[2].ad_role = ROLE_ONLY;
+                wakeup_param->ad_filter[2].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 3
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[3].ad_len = 0;
+                wakeup_param->ad_filter[3].ad_type = 0;
+                //memcpy(wakeup_param->ad_filter[2].ad_data, data,wakeup_param->ad_filter[2].ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
+                wakeup_param->ad_filter[3].ad_data_mask = 0;
+                wakeup_param->ad_filter[3].ad_role = ROLE_COMBO|(COMBO_1<<4);
+                wakeup_param->ad_filter[3].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 4
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[4].ad_len = 0;
+                wakeup_param->ad_filter[4].ad_type = 0x09;
+                //memcpy(wakeup_param->ad_filter[4].ad_data, data,wakeup_param->ad_filter[4].ad_len-1);// 1111 1111 1110 0000 0000 0000 0000 0000 //0xffe00000
+                wakeup_param->ad_filter[4].ad_data_mask = 0xffe00000;
+                wakeup_param->ad_filter[4].ad_role = ROLE_COMBO|(COMBO_1<<4);
+                wakeup_param->ad_filter[4].gpio_trigger_idx = TG_IDX_0|TG_IDX_1;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+
+            for(i = 0; i < (sizeof(struct ble_wakeup_param_t)/4 +1); i++){
                 printk("write_blocks[%d]:0x%08X \r\n", i, write_blocks[i]);
-                rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF0c + (4 * i), write_blocks[i]);
+                rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF00 + (4 * i), write_blocks[i]);
             }
             rwnx_send_dbg_start_app_req(usb_dev, RAM_FW_BLE_SCAN_WAKEUP_ADDR, HOST_START_APP_AUTO);
-            kfree(ad_data);
+            kfree(wakeup_param);
+
             return -1;
-        } else {
+        }else {
             if (rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FW_ADDR, FW_BASE_NAME)) {
                 return -1;;
             }
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.h b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.h
index 066c31b173d4..65ff4f07d99a 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.h
@@ -114,12 +114,46 @@ enum aicwf_usb_state {
     USB_SLEEP_ST
 };
 
-struct ad_data_filter {
+#define MAX_AD_FILTER_NUM        5// Max AD Filter num
+#define MAX_GPIO_TRIGGER_NUM     2// Max user config num of gpio
+#define MAX_ROLE_COMNO_IDX_NUM   2// Max num of ad role type combo,form( enum gpio_combo_idx) 
+
+#define AD_ROLE_FLAG         0x0f
+#define ROLE_COMBO_IDX_FLAG  0xf0
+
+enum ad_role_type {
+    ROLE_ONLY,// ROLE_ONLY will trigger wake up immediately.
+    ROLE_COMBO,//ROLE_COMBO will trigger When all the conditions (ad_role == ROLE_COMBO,and ad_filter is matching)are met.
+};
+
+enum gpio_combo_idx {
+    COMBO_0,
+    COMBO_1,
+};
+
+enum gpio_trigger_bit {
+    TG_IDX_0 = (1<<0),
+    TG_IDX_1 = (1<<1),
+};
+
+struct wakeup_ad_data_filter {
+    uint32_t ad_data_mask;
+    uint8_t gpio_trigger_idx;
+    uint8_t ad_role;//from enum ad_role_type 
     uint8_t ad_len;
     uint8_t ad_type;
     uint8_t ad_data[31];
 };
 
+struct ble_wakeup_param_t {
+    uint32_t magic_num;// "BLES" = 0x53454C42
+    uint32_t delay_scan_to;// timeout for start scan in ms
+    uint32_t reboot_to;// timeout for reboot in ms
+    uint32_t gpio_num[MAX_GPIO_TRIGGER_NUM];
+    uint32_t gpio_dft_lvl[MAX_GPIO_TRIGGER_NUM];
+    struct wakeup_ad_data_filter ad_filter[MAX_AD_FILTER_NUM];
+};
+
 struct aicwf_usb_buf {
     struct list_head list;
     struct aic_usb_dev *usbdev;
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/rwnx_version_gen.h b/drivers/net/wireless/aic8800/aic_load_fw/rwnx_version_gen.h
index 02c315580f52..5de5fc50e1ec 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/rwnx_version_gen.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/rwnx_version_gen.h
@@ -1,4 +1,4 @@
 #define RWNX_VERS_REV "1a4b0054d2M (master)"
 #define RWNX_VERS_MOD "6.4.3.0"
 #define RWNX_VERS_BANNER "rwnx v6.4.3.0 - 1a4b0054d2M (master)"
-#define RELEASE_DATE "2023_0904_1726"
+#define RELEASE_DATE "2023_1212_15dcf017"
-- 
2.34.1

